<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/data/api/LeetnoteApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/data/api/LeetnoteApiService.kt" />
              <option name="originalContent" value="package com.example.leetnote.data.api&#10;&#10;import com.example.leetnote.data.model.PageResponse&#10;import com.example.leetnote.data.model.ProblemDetailDTO&#10;import com.example.leetnote.data.model.ProblemListDTO&#10;import com.example.leetnote.data.model.SetUsernameRequest&#10;import com.example.leetnote.data.model.SubmissionDTO&#10;import com.example.leetnote.data.model.UserProfileDTO&#10;import com.example.leetnote.data.model.EvaluationDetail&#10;import com.example.leetnote.data.model.EvaluationDetailDTO&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;import com.example.leetnote.data.model.LeetcodeStatsDTO&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.DELETE&#10;import retrofit2.http.GET&#10;import retrofit2.http.POST&#10;import retrofit2.http.PUT&#10;import retrofit2.http.Path&#10;import retrofit2.http.Query&#10;&#10;interface LeetnoteApiService {&#10;&#10;    @GET(&quot;api/users/profile&quot;)&#10;    suspend fun getUserProfile(&#10;    ): UserProfileDTO&#10;&#10;    @PUT(&quot;api/users/username&quot;)&#10;    suspend fun setUsername(&#10;        @Body request: SetUsernameRequest&#10;    ): UserProfileDTO&#10;&#10;&#10;&#10;    @GET(&quot;problems&quot;)&#10;    suspend fun getAllProblems(&#10;        @Query(&quot;keyword&quot;) keyword: String? = null,&#10;        @Query(&quot;difficulties&quot;) difficulty: String? = null,&#10;        @Query(&quot;isSolved&quot;) isSolved: Boolean? = null,&#10;        @Query(&quot;isFavorite&quot;) isFavorite: Boolean? = null,&#10;        @Query(&quot;page&quot;) page: Int = 0,&#10;        @Query(&quot;size&quot;) pageSize: Int = 20&#10;    ): PageResponse&lt;ProblemListDTO&gt;&#10;&#10;    @GET(&quot;problems/detail&quot;)&#10;    suspend fun getProblemDetail(&#10;        @Query(&quot;problemId&quot;) problemId: Long,&#10;    ): Response&lt;ProblemDetailDTO&gt;&#10;&#10;    @PUT(&quot;problems/{problemId}/status&quot;)&#10;    suspend fun updateProblemStatus(&#10;        @Path(&quot;problemId&quot;) problemId: Long,&#10;        @Query(&quot;isSolved&quot;) isSolved: Boolean,&#10;        @Query(&quot;isFavorite&quot;) isFavorite: Boolean&#10;    ): ProblemListDTO&#10;&#10;    @GET(&quot;submissions/last&quot;)&#10;    suspend fun getLastSubmission(&#10;        @Query(&quot;problemId&quot;) problemId: Long,&#10;    ): Response&lt;SubmissionDTO.Submission&gt;&#10;&#10;    @POST(&quot;evaluations&quot;)&#10;    suspend fun createEvaluation(&#10;        @Body request: SubmissionDTO.SubmissionRequest&#10;    ): EvaluationDetail&#10;&#10;    @GET(&quot;evaluations/new&quot;)&#10;    suspend fun getNewEvaluation(&#10;        @Query(&quot;problemId&quot;) problemId: Long&#10;    ): Response&lt;EvaluationDetail&gt;&#10;&#10;    @GET(&quot;evaluations/last&quot;)&#10;    suspend fun getLastEvaluation(&#10;        @Query(&quot;evaluationId&quot;) evaluationId: Long? = null,&#10;        @Query(&quot;problemId&quot;) problemId: Long? = null&#10;    ): Response&lt;EvaluationDetailDTO&gt;&#10;&#10;    @GET(&quot;evaluations/all&quot;)&#10;    suspend fun getAllUserEvaluations(): List&lt;EvaluationListItemDTO&gt;&#10;&#10;    @GET(&quot;api/leetcode/profile&quot;)&#10;    suspend fun getLeetcodeProfile(): Response&lt;LeetcodeStatsDTO&gt;&#10;&#10;    @POST(&quot;api/leetcode/username&quot;)&#10;    suspend fun setLeetcodeUsername(&#10;        @Body request: SetUsernameRequest&#10;    ): Response&lt;LeetcodeStatsDTO&gt;&#10;&#10;    @PUT(&quot;api/leetcode/username&quot;)&#10;    suspend fun updateLeetcodeUsername(&#10;        @Body request: SetUsernameRequest&#10;    ): Response&lt;LeetcodeStatsDTO&gt;&#10;&#10;    @POST(&quot;api/leetcode/refresh&quot;)&#10;    suspend fun refreshLeetcodeStats(): Response&lt;LeetcodeStatsDTO&gt;&#10;}" />
              <option name="updatedContent" value="package com.example.leetnote.data.api&#10;&#10;import com.example.leetnote.data.model.PageResponse&#10;import com.example.leetnote.data.model.ProblemDetailDTO&#10;import com.example.leetnote.data.model.ProblemListDTO&#10;import com.example.leetnote.data.model.SetUsernameRequest&#10;import com.example.leetnote.data.model.SubmissionDTO&#10;import com.example.leetnote.data.model.UserProfileDTO&#10;import com.example.leetnote.data.model.EvaluationDetail&#10;import com.example.leetnote.data.model.EvaluationDetailDTO&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;import com.example.leetnote.data.model.LeetcodeStatsDTO&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.DELETE&#10;import retrofit2.http.GET&#10;import retrofit2.http.POST&#10;import retrofit2.http.PUT&#10;import retrofit2.http.Path&#10;import retrofit2.http.Query&#10;&#10;interface LeetnoteApiService {&#10;&#10;    @GET(&quot;api/users/profile&quot;)&#10;    suspend fun getUserProfile(&#10;    ): UserProfileDTO&#10;&#10;    @PUT(&quot;api/users/username&quot;)&#10;    suspend fun setUsername(&#10;        @Body request: SetUsernameRequest&#10;    ): UserProfileDTO&#10;&#10;&#10;&#10;    @GET(&quot;problems&quot;)&#10;    suspend fun getAllProblems(&#10;        @Query(&quot;keyword&quot;) keyword: String? = null,&#10;        @Query(&quot;difficulties&quot;) difficulty: String? = null,&#10;        @Query(&quot;isSolved&quot;) isSolved: Boolean? = null,&#10;        @Query(&quot;isFavorite&quot;) isFavorite: Boolean? = null,&#10;        @Query(&quot;page&quot;) page: Int = 0,&#10;        @Query(&quot;size&quot;) pageSize: Int = 20&#10;    ): PageResponse&lt;ProblemListDTO&gt;&#10;&#10;    @GET(&quot;problems/detail&quot;)&#10;    suspend fun getProblemDetail(&#10;        @Query(&quot;problemId&quot;) problemId: Long,&#10;    ): Response&lt;ProblemDetailDTO&gt;&#10;&#10;    @PUT(&quot;problems/{problemId}/status&quot;)&#10;    suspend fun updateProblemStatus(&#10;        @Path(&quot;problemId&quot;) problemId: Long,&#10;        @Query(&quot;isSolved&quot;) isSolved: Boolean,&#10;        @Query(&quot;isFavorite&quot;) isFavorite: Boolean&#10;    ): ProblemListDTO&#10;&#10;    @GET(&quot;submissions/last&quot;)&#10;    suspend fun getLastSubmission(&#10;        @Query(&quot;problemId&quot;) problemId: Long,&#10;    ): Response&lt;SubmissionDTO.Submission&gt;&#10;&#10;    @POST(&quot;evaluations&quot;)&#10;    suspend fun createEvaluation(&#10;        @Body request: SubmissionDTO.SubmissionRequest&#10;    ): EvaluationDetail&#10;&#10;    @GET(&quot;evaluations/new&quot;)&#10;    suspend fun getNewEvaluation(&#10;        @Query(&quot;problemId&quot;) problemId: Long&#10;    ): Response&lt;EvaluationDetail&gt;&#10;&#10;    @GET(&quot;evaluations/last&quot;)&#10;    suspend fun getLastEvaluation(&#10;        @Query(&quot;evaluationId&quot;) evaluationId: Long? = null,&#10;        @Query(&quot;problemId&quot;) problemId: Long? = null&#10;    ): Response&lt;EvaluationDetailDTO&gt;&#10;&#10;    @GET(&quot;evaluations/all&quot;)&#10;    suspend fun getAllUserEvaluations(): List&lt;EvaluationListItemDTO&gt;&#10;&#10;    @GET(&quot;api/leetcode/profile&quot;)&#10;    suspend fun getLeetcodeProfile(): Response&lt;LeetcodeStatsDTO&gt;&#10;&#10;    @POST(&quot;api/leetcode/username&quot;)&#10;    suspend fun setLeetcodeUsername(&#10;        @Body request: SetUsernameRequest&#10;    ): Response&lt;LeetcodeStatsDTO&gt;&#10;&#10;    @PUT(&quot;api/leetcode/username&quot;)&#10;    suspend fun updateLeetcodeUsername(&#10;        @Body request: SetUsernameRequest&#10;    ): Response&lt;LeetcodeStatsDTO&gt;&#10;&#10;    @POST(&quot;api/leetcode/refresh&quot;)&#10;    suspend fun refreshLeetcodeStats(): Response&lt;LeetcodeStatsDTO&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/data/repository/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/data/repository/UserRepository.kt" />
              <option name="originalContent" value="package com.example.leetnote.data.repository&#10;&#10;import android.net.Uri&#10;import com.example.leetnote.data.api.LeetnoteApiService&#10;import com.example.leetnote.data.model.SetUsernameRequest&#10;import com.example.leetnote.data.model.UserProfileDTO&#10;import com.example.leetnote.data.service.FirebaseStorageService&#10;import javax.inject.Inject&#10;&#10;class UserRepository @Inject constructor(&#10;    private val api: LeetnoteApiService,&#10;    private val firebaseStorageService: FirebaseStorageService&#10;) {&#10;    suspend fun getUserProfile(): UserProfileDTO {&#10;        return api.getUserProfile()&#10;    }&#10;&#10;    suspend fun setUsername(username: String): UserProfileDTO {&#10;        return api.setUsername(SetUsernameRequest(username))&#10;    }&#10;&#10;    suspend fun uploadProfileImage(imageUri: String): String {&#10;        // Parse string URI to Uri object&#10;        val uri = Uri.parse(imageUri)&#10;&#10;        // Upload image to Firebase Storage only&#10;        return firebaseStorageService.uploadProfileImage(uri)&#10;    }&#10;&#10;    suspend fun deleteProfileImage(imageUrl: String) {&#10;        // Delete from Firebase Storage only&#10;        // No backend API call needed&#10;        firebaseStorageService.deleteProfileImage(imageUrl)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.leetnote.data.repository&#10;&#10;import android.net.Uri&#10;import com.example.leetnote.data.api.LeetnoteApiService&#10;import com.example.leetnote.data.model.SetUsernameRequest&#10;import com.example.leetnote.data.model.UserProfileDTO&#10;import com.example.leetnote.data.service.FirebaseStorageService&#10;import javax.inject.Inject&#10;&#10;class UserRepository @Inject constructor(&#10;    private val api: LeetnoteApiService,&#10;    private val firebaseStorageService: FirebaseStorageService&#10;) {&#10;    suspend fun getUserProfile(): UserProfileDTO {&#10;        return api.getUserProfile()&#10;    }&#10;&#10;    suspend fun setUsername(username: String): UserProfileDTO {&#10;        return api.setUsername(SetUsernameRequest(username))&#10;    }&#10;&#10;    suspend fun uploadProfileImage(imageUri: String): String {&#10;        // Parse string URI to Uri object&#10;        val uri = Uri.parse(imageUri)&#10;&#10;        // Upload image to Firebase Storage only&#10;        return firebaseStorageService.uploadProfileImage(uri)&#10;    }&#10;&#10;    suspend fun deleteProfileImage(imageUrl: String) {&#10;        // Delete from Firebase Storage only&#10;        // No backend API call needed&#10;        firebaseStorageService.deleteProfileImage(imageUrl)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/MainScreen.kt" />
              <option name="originalContent" value="package com.example.leetnote.ui&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.leetnote.ui.components.GuidancePopup&#10;import com.example.leetnote.ui.navigation.NavigationGraph&#10;import com.example.leetnote.ui.navigation.Screen&#10;&#10;@Composable&#10;fun MainScreen(&#10;    modifier: Modifier&#10;) {&#10;    val navController = rememberNavController()&#10;    val backStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = backStackEntry?.destination?.route&#10;    val currentScreen = Screen.allScreens.find { it.route == currentRoute } ?: Screen.Home&#10;    val canNavigateBack = navController.previousBackStackEntry != null &amp;&amp;&#10;            currentRoute !in Screen.bottomNavScreens.map { it.route }&#10;    val showTopBar = currentRoute !in listOf(&#10;        Screen.Login.route,&#10;        Screen.Signup.route,&#10;        Screen.Onboarding.route,&#10;        Screen.Splash.route,&#10;        Screen.EvaluationDetail.route&#10;    )&#10;&#10;    Scaffold(&#10;        contentWindowInsets = WindowInsets(0),&#10;        topBar = {&#10;            if (showTopBar) {&#10;                AppBar(&#10;                    currentScreen = currentScreen,&#10;                    canNavigateBack = canNavigateBack,&#10;                    navigateUp = { navController.navigateUp() },&#10;                    navController = navController,&#10;                    modifier = modifier,&#10;                )&#10;            }&#10;        },&#10;        bottomBar = {&#10;            if (currentRoute in Screen.bottomNavScreens.map { it.route}) {&#10;                BottomNavBar(navController = navController)&#10;            }&#10;&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Box(modifier = Modifier.padding(innerPadding)) {&#10;            NavigationGraph(navController = navController)&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun AppBar(&#10;    currentScreen: Screen,&#10;    canNavigateBack: Boolean,&#10;    navigateUp: () -&gt; Unit,&#10;    navController: NavController,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    var showGuidancePopup by remember { mutableStateOf(false) }&#10;&#10;    TopAppBar(&#10;        title = { Text(&#10;            text = currentScreen.title,&#10;            fontWeight = FontWeight.Bold&#10;        ) },&#10;        navigationIcon = {&#10;            if (canNavigateBack) {&#10;                IconButton(onClick = navigateUp) {&#10;                    Icon(&#10;                        imageVector = Icons.Filled.ArrowBack,&#10;                        contentDescription = &quot;Back button&quot;,&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = Color(0xFF6B83DA), // background color&#10;            titleContentColor = Color.White,     // title text color&#10;            navigationIconContentColor = Color.White // nav icon color&#10;        ),&#10;        actions = {&#10;            currentScreen.topIconRes?.let { iconRes -&gt;&#10;                IconButton(onClick = {&#10;                    when (currentScreen) {&#10;                        is Screen.Home -&gt; {&#10;                            navController.navigate(Screen.Settings.route)&#10;                        }&#10;                        is Screen.Solving -&gt; {&#10;                            showGuidancePopup = true&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }) {&#10;                    Icon(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = &quot;Top icon&quot;,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Show guidance popup for solving screen&#10;    if (currentScreen is Screen.Solving) {&#10;        GuidancePopup(&#10;            isVisible = showGuidancePopup,&#10;            onDismiss = { showGuidancePopup = false }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BottomNavBar(navController: NavHostController) {&#10;    val items = listOf(Screen.Home, Screen.Profile, Screen.Learning)&#10;    val currentBackStack by navController.currentBackStackEntryAsState()&#10;    val currentRoute = currentBackStack?.destination?.route&#10;&#10;    Column {&#10;        // Top border line&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(2.dp) // thickness of the border&#10;                .background(Color.Black) // border color (neo-brutalism style)&#10;        )&#10;&#10;        NavigationBar {&#10;            items.forEach { screen -&gt;&#10;                NavigationBarItem(&#10;                    selected = currentRoute == screen.route,&#10;                    onClick = {&#10;                        if (currentRoute != screen.route) {&#10;                            navController.navigate(screen.route) {&#10;                                popUpTo(navController.graph.startDestinationId) {&#10;                                    saveState = true&#10;                                }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    },&#10;                    icon = {&#10;                        screen.iconRes?.let {&#10;                            Icon(&#10;                                painter = painterResource(id = it),&#10;                                contentDescription = screen.title&#10;                            )&#10;                        }&#10;                    },&#10;                    label = { Text(screen.title) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;}" />
              <option name="updatedContent" value="package com.example.leetnote.ui&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.leetnote.ui.components.GuidancePopup&#10;import com.example.leetnote.ui.navigation.NavigationGraph&#10;import com.example.leetnote.ui.navigation.Screen&#10;&#10;@Composable&#10;fun MainScreen(&#10;    modifier: Modifier&#10;) {&#10;    val navController = rememberNavController()&#10;    val backStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = backStackEntry?.destination?.route&#10;    val currentScreen = Screen.allScreens.find { it.route == currentRoute } ?: Screen.Home&#10;    val canNavigateBack = navController.previousBackStackEntry != null &amp;&amp;&#10;            currentRoute !in Screen.bottomNavScreens.map { it.route }&#10;    val showTopBar = currentRoute !in listOf(&#10;        Screen.Login.route,&#10;        Screen.Signup.route,&#10;        Screen.Onboarding.route,&#10;        Screen.Splash.route,&#10;        Screen.EvaluationDetail.route&#10;    )&#10;&#10;    Scaffold(&#10;        contentWindowInsets = WindowInsets(0),&#10;        topBar = {&#10;            if (showTopBar) {&#10;                AppBar(&#10;                    currentScreen = currentScreen,&#10;                    canNavigateBack = canNavigateBack,&#10;                    navigateUp = { navController.navigateUp() },&#10;                    navController = navController,&#10;                    modifier = modifier,&#10;                )&#10;            }&#10;        },&#10;        bottomBar = {&#10;            if (currentRoute in Screen.bottomNavScreens.map { it.route}) {&#10;                BottomNavBar(navController = navController)&#10;            }&#10;&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Box(modifier = Modifier.padding(innerPadding)) {&#10;            NavigationGraph(navController = navController)&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun AppBar(&#10;    currentScreen: Screen,&#10;    canNavigateBack: Boolean,&#10;    navigateUp: () -&gt; Unit,&#10;    navController: NavController,&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    var showGuidancePopup by remember { mutableStateOf(false) }&#10;&#10;    TopAppBar(&#10;        title = { Text(&#10;            text = currentScreen.title,&#10;            fontWeight = FontWeight.Bold&#10;        ) },&#10;        navigationIcon = {&#10;            if (canNavigateBack) {&#10;                IconButton(onClick = navigateUp) {&#10;                    Icon(&#10;                        imageVector = Icons.Filled.ArrowBack,&#10;                        contentDescription = &quot;Back button&quot;,&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = Color(0xFF6B83DA), // background color&#10;            titleContentColor = Color.White,     // title text color&#10;            navigationIconContentColor = Color.White // nav icon color&#10;        ),&#10;        actions = {&#10;            currentScreen.topIconRes?.let { iconRes -&gt;&#10;                IconButton(onClick = {&#10;                    when (currentScreen) {&#10;                        is Screen.Home -&gt; {&#10;                            navController.navigate(Screen.Settings.route)&#10;                        }&#10;                        is Screen.Solving -&gt; {&#10;                            showGuidancePopup = true&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }) {&#10;                    Icon(&#10;                        painter = painterResource(id = iconRes),&#10;                        contentDescription = &quot;Top icon&quot;,&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Show guidance popup for solving screen&#10;    if (currentScreen is Screen.Solving) {&#10;        GuidancePopup(&#10;            isVisible = showGuidancePopup,&#10;            onDismiss = { showGuidancePopup = false }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BottomNavBar(navController: NavHostController) {&#10;    val items = listOf(Screen.Home, Screen.Profile, Screen.Learning)&#10;    val currentBackStack by navController.currentBackStackEntryAsState()&#10;    val currentRoute = currentBackStack?.destination?.route&#10;&#10;    Column {&#10;        // Top border line&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(2.dp) // thickness of the border&#10;                .background(Color.Black) // border color (neo-brutalism style)&#10;        )&#10;&#10;        NavigationBar {&#10;            items.forEach { screen -&gt;&#10;                NavigationBarItem(&#10;                    selected = currentRoute == screen.route,&#10;                    onClick = {&#10;                        if (currentRoute != screen.route) {&#10;                            navController.navigate(screen.route) {&#10;                                popUpTo(navController.graph.startDestinationId) {&#10;                                    saveState = true&#10;                                }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    },&#10;                    icon = {&#10;                        screen.iconRes?.let {&#10;                            Icon(&#10;                                painter = painterResource(id = it),&#10;                                contentDescription = screen.title&#10;                            )&#10;                        }&#10;                    },&#10;                    label = { Text(screen.title) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/screens/onboarding/OnboardingViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/screens/onboarding/OnboardingViewModel.kt" />
              <option name="originalContent" value="package com.example.leetnote.ui.screens.onboarding&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.leetnote.data.repository.OnboardingRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class OnboardingViewModel @Inject constructor(&#10;    private val repository: OnboardingRepository&#10;): ViewModel() {&#10;    val isOnboardingCompleted: StateFlow&lt;Boolean?&gt; =&#10;        repository.isOnboardingCompleted()&#10;            .stateIn(&#10;                scope = viewModelScope, &#10;                started = SharingStarted.WhileSubscribed(5000L), &#10;                initialValue = null&#10;            )&#10;&#10;    fun completeOnboarding() {&#10;        viewModelScope.launch {&#10;            repository.setOnboardingCompleted(true)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.leetnote.ui.screens.onboarding&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.leetnote.data.repository.OnboardingRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class OnboardingViewModel @Inject constructor(&#10;    private val repository: OnboardingRepository&#10;): ViewModel() {&#10;    val isOnboardingCompleted: StateFlow&lt;Boolean?&gt; =&#10;        repository.isOnboardingCompleted()&#10;            .stateIn(&#10;                scope = viewModelScope, &#10;                started = SharingStarted.WhileSubscribed(5000L), &#10;                initialValue = null&#10;            )&#10;&#10;    fun completeOnboarding() {&#10;        viewModelScope.launch {&#10;            repository.setOnboardingCompleted(true)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/screens/profile/ProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/screens/profile/ProfileScreen.kt" />
              <option name="originalContent" value="package com.example.leetnote.ui.screens.profile&#10;&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.example.leetnote.utils.PermissionUtils&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.ModalBottomSheet&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.ProgressIndicatorDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import coil3.compose.AsyncImage&#10;import com.example.leetnote.R&#10;import com.example.leetnote.ui.components.ShadowButton&#10;import com.example.leetnote.ui.navigation.Screen&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.navigation.NavController&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel,&#10;    navController: NavController&#10;) {&#10;    val state by viewModel.uiState.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val error by viewModel.error.collectAsState()&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Show loading indicator&#10;        if (isLoading) {&#10;            LinearProgressIndicator(modifier = Modifier.fillMaxWidth())&#10;        }&#10;&#10;        // Show error message&#10;        error?.let { msg -&gt;&#10;            Text(&#10;                text = msg,&#10;                color = MaterialTheme.colorScheme.error,&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;&#10;        // Profile content&#10;        ProfileContent(&#10;            profileImageUrl = state.profileImageUrl,&#10;            username = state.username,&#10;            level = state.level,&#10;            progress = state.progress,&#10;            leetcodeUsername = state.leetcodeUsername,&#10;            solvedCount = state.solvedCount,&#10;            solvedEasy = state.solvedEasy,&#10;            solvedMedium = state.solvedMedium,&#10;            solvedHard = state.solvedHard,&#10;            easyTotal = 907,&#10;            mediumTotal = 1933,&#10;            hardTotal = 876,&#10;            selectedTabIndex = state.selectedTabIndex,&#10;            evaluations = state.evaluations,&#10;            onLeetCodeConnect = { viewModel.setLeetCodeUsername(it) },&#10;            onLeetCodeUpdate = { viewModel.updateLeetCodeUsername(it) },&#10;            onLeetCodeRefresh = { viewModel.refreshLeetCodeStats() },&#10;            onUploadProfileImage = { newUrl -&gt; viewModel.uploadProfileImage(newUrl) },&#10;            onDeleteProfileImage = { viewModel.deleteProfileImage() },&#10;            onUsernameChange = { newUsername -&gt; viewModel.updateUsername(newUsername) },&#10;            onTabSelected = { newIndex -&gt;&#10;                viewModel.updateTabIndex(newIndex)&#10;                // Load evaluations when Evaluations tab is selected&#10;                if (newIndex == 1) {&#10;                    viewModel.loadAllUserEvaluations()&#10;                }&#10;            },&#10;            onEvaluationClick = { evaluationId -&gt;&#10;                // Find the evaluation to get problemId&#10;                val evaluation = state.evaluations.find { it.evaluationId == evaluationId }&#10;                evaluation?.let {&#10;                    navController.navigate(Screen.EvaluationDetail.createRoute(it.problemId, evaluationId))&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ProfileContent(&#10;    profileImageUrl: String?,&#10;    username: String,&#10;    level: Int,&#10;    progress: Float,&#10;    leetcodeUsername: String?,&#10;    solvedCount: Int?,&#10;    solvedEasy: Int?,&#10;    solvedMedium: Int?,&#10;    solvedHard: Int?,&#10;    easyTotal: Int?,&#10;    mediumTotal: Int?,&#10;    hardTotal: Int?,&#10;    selectedTabIndex: Int,&#10;    evaluations: List&lt;EvaluationListItemDTO&gt;,&#10;    onLeetCodeConnect: (String) -&gt; Unit,&#10;    onLeetCodeUpdate: (String) -&gt; Unit,&#10;    onLeetCodeRefresh: () -&gt; Unit,&#10;    onUploadProfileImage: (String) -&gt; Unit,&#10;    onDeleteProfileImage: () -&gt; Unit,&#10;    onUsernameChange: (String) -&gt; Unit,&#10;    onTabSelected: (Int) -&gt; Unit,&#10;    onEvaluationClick: (Long) -&gt; Unit&#10;) {&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Profile header section&#10;        ProfileHeader(&#10;            profileImageUrl = profileImageUrl,&#10;            username = username,&#10;            level = level,&#10;            progress = progress,&#10;            onUploadProfileImage = onUploadProfileImage,&#10;            onDeleteProfileImage = onDeleteProfileImage,&#10;            onEditUsername = { showEditDialog = true }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Neo-brutalism styled tab row&#10;        NeoBrutalismTabRow(&#10;            selectedTabIndex = selectedTabIndex,&#10;            onTabSelected = onTabSelected&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Content based on selected tab&#10;        when (selectedTabIndex) {&#10;            0 -&gt; {&#10;                // LeetCode content&#10;                if (leetcodeUsername == null) {&#10;                    LeetCodeConnectionSection(&#10;                        onLeetCodeConnect = onLeetCodeConnect&#10;                    )&#10;                } else {&#10;                    LeetCodeStatsSection(&#10;                        leetcodeUsername = leetcodeUsername,&#10;                        solvedCount = solvedCount,&#10;                        solvedEasy = solvedEasy,&#10;                        solvedMedium = solvedMedium,&#10;                        solvedHard = solvedHard,&#10;                        easyTotal = easyTotal,&#10;                        mediumTotal = mediumTotal,&#10;                        hardTotal = hardTotal,&#10;                        onLeetCodeUpdate = onLeetCodeUpdate,&#10;                        onLeetCodeRefresh = onLeetCodeRefresh&#10;                    )&#10;                }&#10;            }&#10;            1 -&gt; {&#10;                // Evaluations content&#10;                EvaluationsSection(&#10;                    evaluations = evaluations,&#10;                    onEvaluationClick = onEvaluationClick&#10;                )&#10;            }&#10;        }&#10;&#10;        if (showEditDialog) {&#10;            UsernameEditDialog(&#10;                currentUsername = username,&#10;                onDismiss = { showEditDialog = false },&#10;                onUpdate = { newUsername -&gt; onUsernameChange(newUsername) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileHeader(&#10;    profileImageUrl: String?,&#10;    username: String,&#10;    level: Int,&#10;    progress: Float,&#10;    onUploadProfileImage: (String) -&gt; Unit,&#10;    onDeleteProfileImage: () -&gt; Unit,&#10;    onEditUsername: () -&gt; Unit&#10;) {&#10;    var showImageSheet by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    val imagePickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.GetContent()&#10;    ) { uri -&gt;&#10;        uri?.let {&#10;            // Pass the URI as string to the ViewModel&#10;            onUploadProfileImage(it.toString())&#10;        }&#10;    }&#10;&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            imagePickerLauncher.launch(&quot;image/*&quot;)&#10;        }&#10;    }&#10;&#10;    fun launchImagePicker() {&#10;        if (PermissionUtils.hasImagePermission(context)) {&#10;            imagePickerLauncher.launch(&quot;image/*&quot;)&#10;        } else {&#10;            permissionLauncher.launch(PermissionUtils.getImagePermission())&#10;        }&#10;    }&#10;&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        ProfileImage(&#10;            profileImageUrl = profileImageUrl,&#10;            onLongClick = { showImageSheet = true }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;        UserInfoCard(&#10;            username = username,&#10;            level = level,&#10;            progress = progress,&#10;            onEditUsername = onEditUsername&#10;        )&#10;    }&#10;&#10;    ProfileImageActionSheet(&#10;        visible = showImageSheet,&#10;        hasImage = !profileImageUrl.isNullOrEmpty(),&#10;        onDismiss = { showImageSheet = false },&#10;        onUpload = {&#10;            showImageSheet = false&#10;            launchImagePicker()&#10;        },&#10;        onRemove = {&#10;            showImageSheet = false&#10;            onDeleteProfileImage()&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun ProfileImage(&#10;    profileImageUrl: String?,&#10;    onLongClick: () -&gt; Unit&#10;) {&#10;    if (!profileImageUrl.isNullOrEmpty()) {&#10;        AsyncImage(&#10;            model = profileImageUrl,&#10;            contentDescription = &quot;Profile Image&quot;,&#10;            modifier = Modifier&#10;                .size(72.dp)&#10;                .border(2.dp, MaterialTheme.colorScheme.outline, CircleShape)&#10;                .clip(CircleShape)&#10;                .combinedClickable(&#10;                    onClick = {},&#10;                    onLongClick = onLongClick&#10;                )&#10;        )&#10;    } else {&#10;        Image(&#10;            painter = painterResource(id = R.drawable.default_profile_photo),&#10;            contentDescription = &quot;Profile Image&quot;,&#10;            modifier = Modifier&#10;                .size(72.dp)&#10;                .border(2.dp, MaterialTheme.colorScheme.outline, CircleShape)&#10;                .clip(CircleShape)&#10;                .combinedClickable(&#10;                    onClick = {},&#10;                    onLongClick = onLongClick&#10;                )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun UserInfoCard(&#10;    username: String,&#10;    level: Int,&#10;    progress: Float,&#10;    onEditUsername: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .border(2.dp, Color.Black, RoundedCornerShape(12.dp))&#10;            .padding(12.dp)&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&#10;                text = username.ifEmpty { &quot;No username&quot; },&#10;                style = MaterialTheme.typography.titleLarge&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Icon(&#10;                imageVector = Icons.Default.Edit,&#10;                contentDescription = &quot;Edit username&quot;,&#10;                modifier = Modifier&#10;                    .size(20.dp)&#10;                    .border(1.5.dp, MaterialTheme.colorScheme.outline, RoundedCornerShape(4.dp))&#10;                    .padding(2.dp)&#10;                    .clickable { onEditUsername() }&#10;            )&#10;        }&#10;&#10;        // Level + progress bar&#10;        Text(text = &quot;Level $level&quot;, style = MaterialTheme.typography.bodyMedium)&#10;        LinearProgressIndicator(&#10;            progress = { progress },&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.6f)&#10;                .height(8.dp)&#10;                .clip(RoundedCornerShape(4.dp)),&#10;            color = ProgressIndicatorDefaults.linearColor,&#10;            trackColor = ProgressIndicatorDefaults.linearTrackColor,&#10;            strokeCap = ProgressIndicatorDefaults.LinearStrokeCap,&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LeetCodeConnectionSection(&#10;    onLeetCodeConnect: (String) -&gt; Unit&#10;) {&#10;    var input by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    Text(text = &quot;Connect your LeetCode profile&quot;, style = MaterialTheme.typography.titleMedium)&#10;    OutlinedTextField(&#10;        value = input,&#10;        onValueChange = { input = it },&#10;        label = { Text(&quot;LeetCode Username&quot;) },&#10;        modifier = Modifier.fillMaxWidth()&#10;    )&#10;    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;    ShadowButton(&#10;        text = &quot;Connect&quot;,&#10;        onClick = { onLeetCodeConnect(input) },&#10;        modifier = Modifier.fillMaxWidth(),&#10;        foregroundColor = Color(0xFF7B9EFF),&#10;        contentColor = Color.White&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun LeetCodeStatsSection(&#10;    leetcodeUsername: String,&#10;    solvedCount: Int?,&#10;    solvedEasy: Int?,&#10;    solvedMedium: Int?,&#10;    solvedHard: Int?,&#10;    easyTotal: Int?,&#10;    mediumTotal: Int?,&#10;    hardTotal: Int?,&#10;    onLeetCodeUpdate: (String) -&gt; Unit,&#10;    onLeetCodeRefresh: () -&gt; Unit&#10;) {&#10;    var showUpdateDialog by remember { mutableStateOf(false) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 16.dp)&#10;    ) {&#10;        // Shadow Card&#10;        Card(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .offset(x = 6.dp, y = 6.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Color.Black),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {}&#10;&#10;        // Main Card&#10;        Card(&#10;            modifier = Modifier&#10;                .border(2.dp, Color.Black, RoundedCornerShape(16.dp)),&#10;            colors = CardDefaults.cardColors(containerColor = Color.White),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier.padding(20.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;LeetCode: $leetcodeUsername&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Row {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Edit,&#10;                            contentDescription = &quot;Update username&quot;,&#10;                            modifier = Modifier&#10;                                .size(20.dp)&#10;                                .clickable { showUpdateDialog = true }&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                OverallProgressIndicator(solvedCount = solvedCount)&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                DifficultyIndicatorsRow(&#10;                    solvedEasy = solvedEasy,&#10;                    solvedMedium = solvedMedium,&#10;                    solvedHard = solvedHard,&#10;                    easyTotal = easyTotal,&#10;                    mediumTotal = mediumTotal,&#10;                    hardTotal = hardTotal&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                ShadowButton(&#10;                    text = &quot;Refresh Stats&quot;,&#10;                    onClick = onLeetCodeRefresh,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    foregroundColor = Color(0xFF7B9EFF),&#10;                    contentColor = Color.White&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showUpdateDialog) {&#10;        LeetCodeUsernameUpdateDialog(&#10;            currentUsername = leetcodeUsername,&#10;            onDismiss = { showUpdateDialog = false },&#10;            onUpdate = { newUsername -&gt;&#10;                onLeetCodeUpdate(newUsername)&#10;                showUpdateDialog = false&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OverallProgressIndicator(&#10;    solvedCount: Int?&#10;) {&#10;    Box(contentAlignment = Alignment.Center) {&#10;        CircularProgressIndicator(&#10;            progress = { (solvedCount?.coerceAtMost(2000) ?: 0) / 2000f },&#10;            strokeWidth = 8.dp,&#10;            modifier = Modifier.size(120.dp)&#10;        )&#10;        Text(&#10;            text = &quot;${solvedCount ?: 0}&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;    }&#10;    Text(&quot;Problems Solved&quot;)&#10;}&#10;&#10;@Composable&#10;private fun DifficultyIndicatorsRow(&#10;    solvedEasy: Int?,&#10;    solvedMedium: Int?,&#10;    solvedHard: Int?,&#10;    easyTotal: Int?,&#10;    mediumTotal: Int?,&#10;    hardTotal: Int?&#10;) {&#10;    Row(modifier = Modifier.fillMaxWidth()) {&#10;        DifficultyIndicator(&#10;            label = &quot;Easy&quot;,&#10;            count = solvedEasy,&#10;            total = easyTotal,&#10;            progressColor = Color(0xFF4CAF50),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;        DifficultyIndicator(&#10;            label = &quot;Medium&quot;,&#10;            count = solvedMedium,&#10;            total = mediumTotal,&#10;            progressColor = Color(0xFFFF9800),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;        DifficultyIndicator(&#10;            label = &quot;Hard&quot;,&#10;            count = solvedHard,&#10;            total = hardTotal,&#10;            progressColor = Color(0xFFF44336),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun UsernameEditDialog(&#10;    currentUsername: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onUpdate: (String) -&gt; Unit&#10;) {&#10;    var newUsername by remember { mutableStateOf(currentUsername) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { onDismiss() },&#10;        title = { Text(&quot;Edit Username&quot;) },&#10;        text = {&#10;            OutlinedTextField(&#10;                value = newUsername,&#10;                onValueChange = { newUsername = it },&#10;                label = { Text(&quot;Username&quot;) },&#10;                singleLine = true&#10;            )&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    onUpdate(newUsername)&#10;                    onDismiss()&#10;                }&#10;            ) {&#10;                Text(&quot;Update&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            Button(onClick = { onDismiss() }) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun LeetCodeUsernameUpdateDialog(&#10;    currentUsername: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onUpdate: (String) -&gt; Unit&#10;) {&#10;    var newUsername by remember { mutableStateOf(currentUsername) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { onDismiss() },&#10;        title = { Text(&quot;Update LeetCode Username&quot;) },&#10;        text = {&#10;            OutlinedTextField(&#10;                value = newUsername,&#10;                onValueChange = { newUsername = it },&#10;                label = { Text(&quot;LeetCode Username&quot;) },&#10;                singleLine = true&#10;            )&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    onUpdate(newUsername)&#10;                    onDismiss()&#10;                }&#10;            ) {&#10;                Text(&quot;Update&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            Button(onClick = { onDismiss() }) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun DifficultyIndicator(&#10;    label: String,&#10;    count: Int?,&#10;    total: Int?,&#10;    progressColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val c = (count ?: 0).coerceAtLeast(0)&#10;    val tRaw = total ?: c&#10;    val t = if (tRaw &lt;= 0) 1 else tRaw&#10;    val progress = (c.toFloat() / t.toFloat()).coerceIn(0f, 1f)&#10;    val totalText = total?.toString() ?: &quot;?&quot;&#10;&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = modifier&#10;    ) {&#10;        Box(contentAlignment = Alignment.Center) {&#10;            CircularProgressIndicator(&#10;                progress = { progress },&#10;                strokeWidth = 6.dp,&#10;                color = progressColor,&#10;                modifier = Modifier.size(64.dp)&#10;            )&#10;            Text(&#10;                text = &quot;$c/$totalText&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.SemiBold&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;private fun ProfileImageActionSheet(&#10;    visible: Boolean,&#10;    hasImage: Boolean,&#10;    onDismiss: () -&gt; Unit,&#10;    onUpload: () -&gt; Unit,&#10;    onRemove: () -&gt; Unit,&#10;) {&#10;    if (!visible) return&#10;&#10;    ModalBottomSheet(&#10;        onDismissRequest = onDismiss&#10;    ) {&#10;        Column(modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp)) {&#10;            Button(onClick = onUpload, modifier = Modifier.fillMaxWidth()) {&#10;                Text(&quot;Upload photo&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(&#10;                onClick = onRemove,&#10;                enabled = hasImage,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;Remove current photo&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            TextButton(onClick = onDismiss, modifier = Modifier.fillMaxWidth()) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EvaluationsSection(&#10;    evaluations: List&lt;EvaluationListItemDTO&gt;,&#10;    onEvaluationClick: (Long) -&gt; Unit&#10;) {&#10;    if (evaluations.isEmpty()) {&#10;        // Empty state&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.DateRange,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(64.dp),&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;No evaluations yet&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Your solution evaluations will appear here&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    } else {&#10;        // Display the list of evaluations&#10;        LazyColumn {&#10;            items(evaluations) { evaluation -&gt;&#10;                EvaluationItem(&#10;                    evaluation = evaluation,&#10;                    onClick = { onEvaluationClick(evaluation.evaluationId) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EvaluationItem(&#10;    evaluation: EvaluationListItemDTO,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    cornerRadius: androidx.compose.ui.unit.Dp = 12.dp,&#10;    shadowOffsetX: androidx.compose.ui.unit.Dp = 4.dp,&#10;    shadowOffsetY: androidx.compose.ui.unit.Dp = 4.dp,&#10;    shadowColor: Color = Color.Black&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 6.dp)&#10;    ) {&#10;        // Shadow Card&#10;        Card(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .offset(x = shadowOffsetX, y = shadowOffsetY),&#10;            colors = CardDefaults.cardColors(containerColor = shadowColor),&#10;            shape = RoundedCornerShape(cornerRadius),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {}&#10;&#10;        // Main Card&#10;        Card(&#10;            modifier = Modifier&#10;                .clickable { onClick() }&#10;                .border(2.dp, Color.Black, RoundedCornerShape(cornerRadius)),&#10;            colors = CardDefaults.cardColors(containerColor = Color.White),&#10;            shape = RoundedCornerShape(cornerRadius),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.Top&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&#10;                            text = evaluation.problemTitle,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            maxLines = 2,&#10;                            overflow = androidx.compose.ui.text.style.TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = null,&#10;                        modifier = Modifier.size(20.dp),&#10;                        tint = Color(0xFF7B9EFF)&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = evaluation.createdAt.split(&quot;T&quot;)[0], // Extract only the date part&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NeoBrutalismTabRow(&#10;    selectedTabIndex: Int,&#10;    onTabSelected: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val tabs = listOf(&quot;LeetCode&quot;, &quot;History&quot;)&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 4.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        tabs.forEachIndexed { index, tab -&gt;&#10;            NeoBrutalismTab(&#10;                text = tab,&#10;                selected = selectedTabIndex == index,&#10;                onClick = { onTabSelected(index) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NeoBrutalismTab(&#10;    text: String,&#10;    selected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val backgroundColor = if (selected) Color(0xFF7B9EFF) else Color.White&#10;    val textColor = if (selected) Color.White else Color.Black&#10;    val shadowColor = if (selected) Color(0xFF5A7CD8) else Color.Gray&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .height(48.dp)&#10;    ) {&#10;        // Tab shadow&#10;        Box(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .offset(x = 2.dp, y = 2.dp)&#10;                .background(&#10;                    color = shadowColor,&#10;                    shape = RoundedCornerShape(8.dp)&#10;                )&#10;        )&#10;&#10;        // Main tab&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .border(2.dp, Color.Black, RoundedCornerShape(8.dp))&#10;                .background(&#10;                    color = backgroundColor,&#10;                    shape = RoundedCornerShape(8.dp)&#10;                )&#10;                .clickable { onClick() },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = textColor&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ProfileScreenPreview() {&#10;    MaterialTheme {&#10;        ProfileContent(&#10;            profileImageUrl = &quot;https://avatars.githubusercontent.com/u/1?v=4&quot;,&#10;            username = &quot;Nguyen Tan&quot;,&#10;            level = 5,&#10;            progress = 0.65f,&#10;            leetcodeUsername = &quot;tanNguyen123&quot;,&#10;            solvedCount = 350,&#10;            solvedEasy = 150,&#10;            solvedMedium = 150,&#10;            solvedHard = 50,&#10;            easyTotal = 300,&#10;            mediumTotal = 500,&#10;            hardTotal = 100,&#10;            selectedTabIndex = 0,&#10;            evaluations = listOf(),&#10;            onLeetCodeConnect = {},&#10;            onLeetCodeUpdate = {},&#10;            onLeetCodeRefresh = {},&#10;            onUploadProfileImage = {},&#10;            onDeleteProfileImage = {},&#10;            onUsernameChange = {},&#10;            onTabSelected = {},&#10;            onEvaluationClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ProfileScreenFirstTimePreview() {&#10;    MaterialTheme {&#10;        ProfileContent(&#10;            profileImageUrl = null,&#10;            username = &quot;New User&quot;,&#10;            level = 1,&#10;            progress = 0.1f,&#10;            leetcodeUsername = null,&#10;            solvedCount = null,&#10;            solvedEasy = null,&#10;            solvedMedium = null,&#10;            solvedHard = null,&#10;            easyTotal = null,&#10;            mediumTotal = null,&#10;            hardTotal = null,&#10;            selectedTabIndex = 0,&#10;            evaluations = listOf(),&#10;            onLeetCodeConnect = {},&#10;            onLeetCodeUpdate = {},&#10;            onLeetCodeRefresh = {},&#10;            onUploadProfileImage = {},&#10;            onDeleteProfileImage = {},&#10;            onUsernameChange = {},&#10;            onTabSelected = {},&#10;            onEvaluationClick = {}&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.leetnote.ui.screens.profile&#10;&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.example.leetnote.utils.PermissionUtils&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.combinedClickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.ModalBottomSheet&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.ProgressIndicatorDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import coil3.compose.AsyncImage&#10;import com.example.leetnote.R&#10;import com.example.leetnote.ui.components.ShadowButton&#10;import com.example.leetnote.ui.navigation.Screen&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.navigation.NavController&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel,&#10;    navController: NavController&#10;) {&#10;    val state by viewModel.uiState.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val error by viewModel.error.collectAsState()&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Show loading indicator&#10;        if (isLoading) {&#10;            LinearProgressIndicator(modifier = Modifier.fillMaxWidth())&#10;        }&#10;&#10;        // Show error message&#10;        error?.let { msg -&gt;&#10;            Text(&#10;                text = msg,&#10;                color = MaterialTheme.colorScheme.error,&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;&#10;        // Profile content&#10;        ProfileContent(&#10;            profileImageUrl = state.profileImageUrl,&#10;            username = state.username,&#10;            level = state.level,&#10;            progress = state.progress,&#10;            leetcodeUsername = state.leetcodeUsername,&#10;            solvedCount = state.solvedCount,&#10;            solvedEasy = state.solvedEasy,&#10;            solvedMedium = state.solvedMedium,&#10;            solvedHard = state.solvedHard,&#10;            easyTotal = 907,&#10;            mediumTotal = 1933,&#10;            hardTotal = 876,&#10;            selectedTabIndex = state.selectedTabIndex,&#10;            evaluations = state.evaluations,&#10;            onLeetCodeConnect = { viewModel.setLeetCodeUsername(it) },&#10;            onLeetCodeUpdate = { viewModel.updateLeetCodeUsername(it) },&#10;            onLeetCodeRefresh = { viewModel.refreshLeetCodeStats() },&#10;            onUploadProfileImage = { newUrl -&gt; viewModel.uploadProfileImage(newUrl) },&#10;            onDeleteProfileImage = { viewModel.deleteProfileImage() },&#10;            onUsernameChange = { newUsername -&gt; viewModel.updateUsername(newUsername) },&#10;            onTabSelected = { newIndex -&gt;&#10;                viewModel.updateTabIndex(newIndex)&#10;                // Load evaluations when Evaluations tab is selected&#10;                if (newIndex == 1) {&#10;                    viewModel.loadAllUserEvaluations()&#10;                }&#10;            },&#10;            onEvaluationClick = { evaluationId -&gt;&#10;                // Find the evaluation to get problemId&#10;                val evaluation = state.evaluations.find { it.evaluationId == evaluationId }&#10;                evaluation?.let {&#10;                    navController.navigate(Screen.EvaluationDetail.createRoute(it.problemId, evaluationId))&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ProfileContent(&#10;    profileImageUrl: String?,&#10;    username: String,&#10;    level: Int,&#10;    progress: Float,&#10;    leetcodeUsername: String?,&#10;    solvedCount: Int?,&#10;    solvedEasy: Int?,&#10;    solvedMedium: Int?,&#10;    solvedHard: Int?,&#10;    easyTotal: Int?,&#10;    mediumTotal: Int?,&#10;    hardTotal: Int?,&#10;    selectedTabIndex: Int,&#10;    evaluations: List&lt;EvaluationListItemDTO&gt;,&#10;    onLeetCodeConnect: (String) -&gt; Unit,&#10;    onLeetCodeUpdate: (String) -&gt; Unit,&#10;    onLeetCodeRefresh: () -&gt; Unit,&#10;    onUploadProfileImage: (String) -&gt; Unit,&#10;    onDeleteProfileImage: () -&gt; Unit,&#10;    onUsernameChange: (String) -&gt; Unit,&#10;    onTabSelected: (Int) -&gt; Unit,&#10;    onEvaluationClick: (Long) -&gt; Unit&#10;) {&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Profile header section&#10;        ProfileHeader(&#10;            profileImageUrl = profileImageUrl,&#10;            username = username,&#10;            level = level,&#10;            progress = progress,&#10;            onUploadProfileImage = onUploadProfileImage,&#10;            onDeleteProfileImage = onDeleteProfileImage,&#10;            onEditUsername = { showEditDialog = true }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Neo-brutalism styled tab row&#10;        NeoBrutalismTabRow(&#10;            selectedTabIndex = selectedTabIndex,&#10;            onTabSelected = onTabSelected&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Content based on selected tab&#10;        when (selectedTabIndex) {&#10;            0 -&gt; {&#10;                // LeetCode content&#10;                if (leetcodeUsername == null) {&#10;                    LeetCodeConnectionSection(&#10;                        onLeetCodeConnect = onLeetCodeConnect&#10;                    )&#10;                } else {&#10;                    LeetCodeStatsSection(&#10;                        leetcodeUsername = leetcodeUsername,&#10;                        solvedCount = solvedCount,&#10;                        solvedEasy = solvedEasy,&#10;                        solvedMedium = solvedMedium,&#10;                        solvedHard = solvedHard,&#10;                        easyTotal = easyTotal,&#10;                        mediumTotal = mediumTotal,&#10;                        hardTotal = hardTotal,&#10;                        onLeetCodeUpdate = onLeetCodeUpdate,&#10;                        onLeetCodeRefresh = onLeetCodeRefresh&#10;                    )&#10;                }&#10;            }&#10;            1 -&gt; {&#10;                // Evaluations content&#10;                EvaluationsSection(&#10;                    evaluations = evaluations,&#10;                    onEvaluationClick = onEvaluationClick&#10;                )&#10;            }&#10;        }&#10;&#10;        if (showEditDialog) {&#10;            UsernameEditDialog(&#10;                currentUsername = username,&#10;                onDismiss = { showEditDialog = false },&#10;                onUpdate = { newUsername -&gt; onUsernameChange(newUsername) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileHeader(&#10;    profileImageUrl: String?,&#10;    username: String,&#10;    level: Int,&#10;    progress: Float,&#10;    onUploadProfileImage: (String) -&gt; Unit,&#10;    onDeleteProfileImage: () -&gt; Unit,&#10;    onEditUsername: () -&gt; Unit&#10;) {&#10;    var showImageSheet by remember { mutableStateOf(false) }&#10;    val context = LocalContext.current&#10;&#10;    val imagePickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.GetContent()&#10;    ) { uri -&gt;&#10;        uri?.let {&#10;            // Pass the URI as string to the ViewModel&#10;            onUploadProfileImage(it.toString())&#10;        }&#10;    }&#10;&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            imagePickerLauncher.launch(&quot;image/*&quot;)&#10;        }&#10;    }&#10;&#10;    fun launchImagePicker() {&#10;        if (PermissionUtils.hasImagePermission(context)) {&#10;            imagePickerLauncher.launch(&quot;image/*&quot;)&#10;        } else {&#10;            permissionLauncher.launch(PermissionUtils.getImagePermission())&#10;        }&#10;    }&#10;&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        ProfileImage(&#10;            profileImageUrl = profileImageUrl,&#10;            onLongClick = { showImageSheet = true }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;        UserInfoCard(&#10;            username = username,&#10;            level = level,&#10;            progress = progress,&#10;            onEditUsername = onEditUsername&#10;        )&#10;    }&#10;&#10;    ProfileImageActionSheet(&#10;        visible = showImageSheet,&#10;        hasImage = !profileImageUrl.isNullOrEmpty(),&#10;        onDismiss = { showImageSheet = false },&#10;        onUpload = {&#10;            showImageSheet = false&#10;            launchImagePicker()&#10;        },&#10;        onRemove = {&#10;            showImageSheet = false&#10;            onDeleteProfileImage()&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun ProfileImage(&#10;    profileImageUrl: String?,&#10;    onLongClick: () -&gt; Unit&#10;) {&#10;    if (!profileImageUrl.isNullOrEmpty()) {&#10;        AsyncImage(&#10;            model = profileImageUrl,&#10;            contentDescription = &quot;Profile Image&quot;,&#10;            modifier = Modifier&#10;                .size(72.dp)&#10;                .border(2.dp, MaterialTheme.colorScheme.outline, CircleShape)&#10;                .clip(CircleShape)&#10;                .combinedClickable(&#10;                    onClick = {},&#10;                    onLongClick = onLongClick&#10;                )&#10;        )&#10;    } else {&#10;        Image(&#10;            painter = painterResource(id = R.drawable.default_profile_photo),&#10;            contentDescription = &quot;Profile Image&quot;,&#10;            modifier = Modifier&#10;                .size(72.dp)&#10;                .border(2.dp, MaterialTheme.colorScheme.outline, CircleShape)&#10;                .clip(CircleShape)&#10;                .combinedClickable(&#10;                    onClick = {},&#10;                    onLongClick = onLongClick&#10;                )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun UserInfoCard(&#10;    username: String,&#10;    level: Int,&#10;    progress: Float,&#10;    onEditUsername: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .border(2.dp, Color.Black, RoundedCornerShape(12.dp))&#10;            .padding(12.dp)&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&#10;                text = username.ifEmpty { &quot;No username&quot; },&#10;                style = MaterialTheme.typography.titleLarge&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Icon(&#10;                imageVector = Icons.Default.Edit,&#10;                contentDescription = &quot;Edit username&quot;,&#10;                modifier = Modifier&#10;                    .size(20.dp)&#10;                    .border(1.5.dp, MaterialTheme.colorScheme.outline, RoundedCornerShape(4.dp))&#10;                    .padding(2.dp)&#10;                    .clickable { onEditUsername() }&#10;            )&#10;        }&#10;&#10;        // Level + progress bar&#10;        Text(text = &quot;Level $level&quot;, style = MaterialTheme.typography.bodyMedium)&#10;        LinearProgressIndicator(&#10;            progress = { progress },&#10;            modifier = Modifier&#10;                .fillMaxWidth(0.6f)&#10;                .height(8.dp)&#10;                .clip(RoundedCornerShape(4.dp)),&#10;            color = ProgressIndicatorDefaults.linearColor,&#10;            trackColor = ProgressIndicatorDefaults.linearTrackColor,&#10;            strokeCap = ProgressIndicatorDefaults.LinearStrokeCap,&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LeetCodeConnectionSection(&#10;    onLeetCodeConnect: (String) -&gt; Unit&#10;) {&#10;    var input by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    Text(text = &quot;Connect your LeetCode profile&quot;, style = MaterialTheme.typography.titleMedium)&#10;    OutlinedTextField(&#10;        value = input,&#10;        onValueChange = { input = it },&#10;        label = { Text(&quot;LeetCode Username&quot;) },&#10;        modifier = Modifier.fillMaxWidth()&#10;    )&#10;    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;    ShadowButton(&#10;        text = &quot;Connect&quot;,&#10;        onClick = { onLeetCodeConnect(input) },&#10;        modifier = Modifier.fillMaxWidth(),&#10;        foregroundColor = Color(0xFF7B9EFF),&#10;        contentColor = Color.White&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun LeetCodeStatsSection(&#10;    leetcodeUsername: String,&#10;    solvedCount: Int?,&#10;    solvedEasy: Int?,&#10;    solvedMedium: Int?,&#10;    solvedHard: Int?,&#10;    easyTotal: Int?,&#10;    mediumTotal: Int?,&#10;    hardTotal: Int?,&#10;    onLeetCodeUpdate: (String) -&gt; Unit,&#10;    onLeetCodeRefresh: () -&gt; Unit&#10;) {&#10;    var showUpdateDialog by remember { mutableStateOf(false) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 16.dp)&#10;    ) {&#10;        // Shadow Card&#10;        Card(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .offset(x = 6.dp, y = 6.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Color.Black),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {}&#10;&#10;        // Main Card&#10;        Card(&#10;            modifier = Modifier&#10;                .border(2.dp, Color.Black, RoundedCornerShape(16.dp)),&#10;            colors = CardDefaults.cardColors(containerColor = Color.White),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier.padding(20.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;LeetCode: $leetcodeUsername&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Row {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Edit,&#10;                            contentDescription = &quot;Update username&quot;,&#10;                            modifier = Modifier&#10;                                .size(20.dp)&#10;                                .clickable { showUpdateDialog = true }&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                OverallProgressIndicator(solvedCount = solvedCount)&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                DifficultyIndicatorsRow(&#10;                    solvedEasy = solvedEasy,&#10;                    solvedMedium = solvedMedium,&#10;                    solvedHard = solvedHard,&#10;                    easyTotal = easyTotal,&#10;                    mediumTotal = mediumTotal,&#10;                    hardTotal = hardTotal&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                ShadowButton(&#10;                    text = &quot;Refresh Stats&quot;,&#10;                    onClick = onLeetCodeRefresh,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    foregroundColor = Color(0xFF7B9EFF),&#10;                    contentColor = Color.White&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showUpdateDialog) {&#10;        LeetCodeUsernameUpdateDialog(&#10;            currentUsername = leetcodeUsername,&#10;            onDismiss = { showUpdateDialog = false },&#10;            onUpdate = { newUsername -&gt;&#10;                onLeetCodeUpdate(newUsername)&#10;                showUpdateDialog = false&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun OverallProgressIndicator(&#10;    solvedCount: Int?&#10;) {&#10;    Box(contentAlignment = Alignment.Center) {&#10;        CircularProgressIndicator(&#10;            progress = { (solvedCount?.coerceAtMost(2000) ?: 0) / 2000f },&#10;            strokeWidth = 8.dp,&#10;            modifier = Modifier.size(120.dp)&#10;        )&#10;        Text(&#10;            text = &quot;${solvedCount ?: 0}&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;    }&#10;    Text(&quot;Problems Solved&quot;)&#10;}&#10;&#10;@Composable&#10;private fun DifficultyIndicatorsRow(&#10;    solvedEasy: Int?,&#10;    solvedMedium: Int?,&#10;    solvedHard: Int?,&#10;    easyTotal: Int?,&#10;    mediumTotal: Int?,&#10;    hardTotal: Int?&#10;) {&#10;    Row(modifier = Modifier.fillMaxWidth()) {&#10;        DifficultyIndicator(&#10;            label = &quot;Easy&quot;,&#10;            count = solvedEasy,&#10;            total = easyTotal,&#10;            progressColor = Color(0xFF4CAF50),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;        DifficultyIndicator(&#10;            label = &quot;Medium&quot;,&#10;            count = solvedMedium,&#10;            total = mediumTotal,&#10;            progressColor = Color(0xFFFF9800),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;        DifficultyIndicator(&#10;            label = &quot;Hard&quot;,&#10;            count = solvedHard,&#10;            total = hardTotal,&#10;            progressColor = Color(0xFFF44336),&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun UsernameEditDialog(&#10;    currentUsername: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onUpdate: (String) -&gt; Unit&#10;) {&#10;    var newUsername by remember { mutableStateOf(currentUsername) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { onDismiss() },&#10;        title = { Text(&quot;Edit Username&quot;) },&#10;        text = {&#10;            OutlinedTextField(&#10;                value = newUsername,&#10;                onValueChange = { newUsername = it },&#10;                label = { Text(&quot;Username&quot;) },&#10;                singleLine = true&#10;            )&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    onUpdate(newUsername)&#10;                    onDismiss()&#10;                }&#10;            ) {&#10;                Text(&quot;Update&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            Button(onClick = { onDismiss() }) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun LeetCodeUsernameUpdateDialog(&#10;    currentUsername: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onUpdate: (String) -&gt; Unit&#10;) {&#10;    var newUsername by remember { mutableStateOf(currentUsername) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = { onDismiss() },&#10;        title = { Text(&quot;Update LeetCode Username&quot;) },&#10;        text = {&#10;            OutlinedTextField(&#10;                value = newUsername,&#10;                onValueChange = { newUsername = it },&#10;                label = { Text(&quot;LeetCode Username&quot;) },&#10;                singleLine = true&#10;            )&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = {&#10;                    onUpdate(newUsername)&#10;                    onDismiss()&#10;                }&#10;            ) {&#10;                Text(&quot;Update&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            Button(onClick = { onDismiss() }) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun DifficultyIndicator(&#10;    label: String,&#10;    count: Int?,&#10;    total: Int?,&#10;    progressColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val c = (count ?: 0).coerceAtLeast(0)&#10;    val tRaw = total ?: c&#10;    val t = if (tRaw &lt;= 0) 1 else tRaw&#10;    val progress = (c.toFloat() / t.toFloat()).coerceIn(0f, 1f)&#10;    val totalText = total?.toString() ?: &quot;?&quot;&#10;&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = modifier&#10;    ) {&#10;        Box(contentAlignment = Alignment.Center) {&#10;            CircularProgressIndicator(&#10;                progress = { progress },&#10;                strokeWidth = 6.dp,&#10;                color = progressColor,&#10;                modifier = Modifier.size(64.dp)&#10;            )&#10;            Text(&#10;                text = &quot;$c/$totalText&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.SemiBold&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;private fun ProfileImageActionSheet(&#10;    visible: Boolean,&#10;    hasImage: Boolean,&#10;    onDismiss: () -&gt; Unit,&#10;    onUpload: () -&gt; Unit,&#10;    onRemove: () -&gt; Unit,&#10;) {&#10;    if (!visible) return&#10;&#10;    ModalBottomSheet(&#10;        onDismissRequest = onDismiss&#10;    ) {&#10;        Column(modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp)) {&#10;            Button(onClick = onUpload, modifier = Modifier.fillMaxWidth()) {&#10;                Text(&quot;Upload photo&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(&#10;                onClick = onRemove,&#10;                enabled = hasImage,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;Remove current photo&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            TextButton(onClick = onDismiss, modifier = Modifier.fillMaxWidth()) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EvaluationsSection(&#10;    evaluations: List&lt;EvaluationListItemDTO&gt;,&#10;    onEvaluationClick: (Long) -&gt; Unit&#10;) {&#10;    if (evaluations.isEmpty()) {&#10;        // Empty state&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.DateRange,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(64.dp),&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;No evaluations yet&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Your solution evaluations will appear here&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                textAlign = TextAlign.Center&#10;            )&#10;        }&#10;    } else {&#10;        // Display the list of evaluations&#10;        LazyColumn {&#10;            items(evaluations) { evaluation -&gt;&#10;                EvaluationItem(&#10;                    evaluation = evaluation,&#10;                    onClick = { onEvaluationClick(evaluation.evaluationId) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EvaluationItem(&#10;    evaluation: EvaluationListItemDTO,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    cornerRadius: androidx.compose.ui.unit.Dp = 12.dp,&#10;    shadowOffsetX: androidx.compose.ui.unit.Dp = 4.dp,&#10;    shadowOffsetY: androidx.compose.ui.unit.Dp = 4.dp,&#10;    shadowColor: Color = Color.Black&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 6.dp)&#10;    ) {&#10;        // Shadow Card&#10;        Card(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .offset(x = shadowOffsetX, y = shadowOffsetY),&#10;            colors = CardDefaults.cardColors(containerColor = shadowColor),&#10;            shape = RoundedCornerShape(cornerRadius),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {}&#10;&#10;        // Main Card&#10;        Card(&#10;            modifier = Modifier&#10;                .clickable { onClick() }&#10;                .border(2.dp, Color.Black, RoundedCornerShape(cornerRadius)),&#10;            colors = CardDefaults.cardColors(containerColor = Color.White),&#10;            shape = RoundedCornerShape(cornerRadius),&#10;            elevation = CardDefaults.cardElevation(0.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.Top&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&#10;                            text = evaluation.problemTitle,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            maxLines = 2,&#10;                            overflow = androidx.compose.ui.text.style.TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;&#10;                    Icon(&#10;                        imageVector = Icons.Default.DateRange,&#10;                        contentDescription = null,&#10;                        modifier = Modifier.size(20.dp),&#10;                        tint = Color(0xFF7B9EFF)&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = evaluation.createdAt.split(&quot;T&quot;)[0], // Extract only the date part&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NeoBrutalismTabRow(&#10;    selectedTabIndex: Int,&#10;    onTabSelected: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val tabs = listOf(&quot;LeetCode&quot;, &quot;History&quot;)&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 4.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        tabs.forEachIndexed { index, tab -&gt;&#10;            NeoBrutalismTab(&#10;                text = tab,&#10;                selected = selectedTabIndex == index,&#10;                onClick = { onTabSelected(index) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NeoBrutalismTab(&#10;    text: String,&#10;    selected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val backgroundColor = if (selected) Color(0xFF7B9EFF) else Color.White&#10;    val textColor = if (selected) Color.White else Color.Black&#10;    val shadowColor = if (selected) Color(0xFF5A7CD8) else Color.Gray&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .height(48.dp)&#10;    ) {&#10;        // Tab shadow&#10;        Box(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .offset(x = 2.dp, y = 2.dp)&#10;                .background(&#10;                    color = shadowColor,&#10;                    shape = RoundedCornerShape(8.dp)&#10;                )&#10;        )&#10;&#10;        // Main tab&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .border(2.dp, Color.Black, RoundedCornerShape(8.dp))&#10;                .background(&#10;                    color = backgroundColor,&#10;                    shape = RoundedCornerShape(8.dp)&#10;                )&#10;                .clickable { onClick() },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = textColor&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ProfileScreenPreview() {&#10;    MaterialTheme {&#10;        ProfileContent(&#10;            profileImageUrl = &quot;https://avatars.githubusercontent.com/u/1?v=4&quot;,&#10;            username = &quot;Nguyen Tan&quot;,&#10;            level = 5,&#10;            progress = 0.65f,&#10;            leetcodeUsername = &quot;tanNguyen123&quot;,&#10;            solvedCount = 350,&#10;            solvedEasy = 150,&#10;            solvedMedium = 150,&#10;            solvedHard = 50,&#10;            easyTotal = 300,&#10;            mediumTotal = 500,&#10;            hardTotal = 100,&#10;            selectedTabIndex = 0,&#10;            evaluations = listOf(),&#10;            onLeetCodeConnect = {},&#10;            onLeetCodeUpdate = {},&#10;            onLeetCodeRefresh = {},&#10;            onUploadProfileImage = {},&#10;            onDeleteProfileImage = {},&#10;            onUsernameChange = {},&#10;            onTabSelected = {},&#10;            onEvaluationClick = {}&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ProfileScreenFirstTimePreview() {&#10;    MaterialTheme {&#10;        ProfileContent(&#10;            profileImageUrl = null,&#10;            username = &quot;New User&quot;,&#10;            level = 1,&#10;            progress = 0.1f,&#10;            leetcodeUsername = null,&#10;            solvedCount = null,&#10;            solvedEasy = null,&#10;            solvedMedium = null,&#10;            solvedHard = null,&#10;            easyTotal = null,&#10;            mediumTotal = null,&#10;            hardTotal = null,&#10;            selectedTabIndex = 0,&#10;            evaluations = listOf(),&#10;            onLeetCodeConnect = {},&#10;            onLeetCodeUpdate = {},&#10;            onLeetCodeRefresh = {},&#10;            onUploadProfileImage = {},&#10;            onDeleteProfileImage = {},&#10;            onUsernameChange = {},&#10;            onTabSelected = {},&#10;            onEvaluationClick = {}&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/screens/profile/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/leetnote/ui/screens/profile/ProfileViewModel.kt" />
              <option name="originalContent" value="package com.example.leetnote.ui.screens.profile&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.leetnote.data.repository.UserRepository&#10;import com.example.leetnote.data.repository.LeetcodeRepository&#10;import com.example.leetnote.data.repository.EvaluationRepository&#10;import com.example.leetnote.data.model.EvaluationDetailDTO&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;data class ProfileUiState(&#10;    val profileImageUrl: String? = null,&#10;    val username: String = &quot;&quot;,&#10;    val email: String = &quot;&quot;,&#10;    val level: Int = 0,&#10;    val progress: Float = 0f,&#10;    val leetcodeUsername: String? = null,&#10;    val solvedCount: Int? = null,&#10;    val solvedEasy: Int? = null,&#10;    val solvedMedium: Int? = null,&#10;    val solvedHard: Int? = null,&#10;    val easyTotal: Int? = 907,&#10;    val mediumTotal: Int? = 1933,&#10;    val hardTotal: Int? = 876,&#10;    val selectedTabIndex: Int = 0,&#10;    val evaluations: List&lt;EvaluationListItemDTO&gt; = emptyList(),&#10;    val selectedEvaluationDetail: EvaluationDetailDTO? = null&#10;)&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val userRepository: UserRepository,&#10;    private val leetcodeRepository: LeetcodeRepository,&#10;    private val evaluationRepository: EvaluationRepository&#10;): ViewModel() {&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()&#10;&#10;    init {&#10;        loadUserProfile()&#10;        loadLeetCodeProfile()&#10;    }&#10;&#10;    fun selectTab(tabIndex: Int) {&#10;        _uiState.update { it.copy(selectedTabIndex = tabIndex) }&#10;    }&#10;&#10;    fun updateTabIndex(tabIndex: Int) {&#10;        _uiState.update { it.copy(selectedTabIndex = tabIndex) }&#10;    }&#10;&#10;    fun loadAllUserEvaluations() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val evaluations = evaluationRepository.getAllUserEvaluations()&#10;                _uiState.update { it.copy(evaluations = evaluations) }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Failed to load evaluations: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getEvaluationDetail(evaluationId: Long) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val evaluationDetail = evaluationRepository.getEvaluationById(evaluationId)&#10;                _uiState.update { it.copy(selectedEvaluationDetail = evaluationDetail) }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Failed to load evaluation detail: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val profile = userRepository.getUserProfile()&#10;                _uiState.update {&#10;                    it.copy(&#10;                        email = profile.email,&#10;                        username = profile.username,&#10;                        profileImageUrl = profile.profileUrl&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateUsername(newUsername: String) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val updatedProfile = userRepository.setUsername(newUsername)&#10;                _uiState.update {&#10;                    it.copy(&#10;                        username = updatedProfile.username&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun uploadProfileImage(imageUrl: String) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val uploadedUrl = userRepository.uploadProfileImage(imageUrl)&#10;                _uiState.update { it.copy(profileImageUrl = uploadedUrl) }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteProfileImage() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val currentImageUrl = _uiState.value.profileImageUrl&#10;                if (currentImageUrl != null) {&#10;                    userRepository.deleteProfileImage(currentImageUrl)&#10;                }&#10;                _uiState.update { it.copy(profileImageUrl = null) }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load user's stored LeetCode profile from database&#10;     * Called on init to check if user has already connected their LeetCode account&#10;     */&#10;    fun loadLeetCodeProfile() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.getLeetcodeProfile()&#10;                if (stats != null) {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                // Silently fail if no profile exists yet&#10;                _error.value = null&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set LeetCode username for the first time&#10;     * This will fetch fresh stats from LeetCode API and save to database&#10;     */&#10;    fun setLeetCodeUsername(username: String) {&#10;        if (username.isBlank()) {&#10;            _error.value = &quot;LeetCode username can't be empty&quot;&#10;            return&#10;        }&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.setLeetcodeUsername(username)&#10;                if (stats == null) {&#10;                    _error.value = &quot;Failed to fetch LeetCode stats. Please check the username.&quot;&#10;                } else {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Error: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update LeetCode username to a new one&#10;     * This will fetch fresh stats for the new username and save to database&#10;     */&#10;    fun updateLeetCodeUsername(username: String) {&#10;        if (username.isBlank()) {&#10;            _error.value = &quot;LeetCode username can't be empty&quot;&#10;            return&#10;        }&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.updateLeetcodeUsername(username)&#10;                if (stats == null) {&#10;                    _error.value = &quot;Failed to update LeetCode username. Please check the username.&quot;&#10;                } else {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Error: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh stats from LeetCode API for existing username&#10;     * Use this when user wants to manually update their stats&#10;     */&#10;    fun refreshLeetCodeStats() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.refreshLeetcodeStats()&#10;                if (stats == null) {&#10;                    _error.value = &quot;Failed to refresh LeetCode stats&quot;&#10;                } else {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Error: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.leetnote.ui.screens.profile&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.leetnote.data.repository.UserRepository&#10;import com.example.leetnote.data.repository.LeetcodeRepository&#10;import com.example.leetnote.data.repository.EvaluationRepository&#10;import com.example.leetnote.data.model.EvaluationDetailDTO&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;data class ProfileUiState(&#10;    val profileImageUrl: String? = null,&#10;    val username: String = &quot;&quot;,&#10;    val email: String = &quot;&quot;,&#10;    val level: Int = 0,&#10;    val progress: Float = 0f,&#10;    val leetcodeUsername: String? = null,&#10;    val solvedCount: Int? = null,&#10;    val solvedEasy: Int? = null,&#10;    val solvedMedium: Int? = null,&#10;    val solvedHard: Int? = null,&#10;    val easyTotal: Int? = 907,&#10;    val mediumTotal: Int? = 1933,&#10;    val hardTotal: Int? = 876,&#10;    val selectedTabIndex: Int = 0,&#10;    val evaluations: List&lt;EvaluationListItemDTO&gt; = emptyList(),&#10;    val selectedEvaluationDetail: EvaluationDetailDTO? = null&#10;)&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val userRepository: UserRepository,&#10;    private val leetcodeRepository: LeetcodeRepository,&#10;    private val evaluationRepository: EvaluationRepository&#10;): ViewModel() {&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()&#10;&#10;    init {&#10;        loadUserProfile()&#10;        loadLeetCodeProfile()&#10;    }&#10;&#10;    fun selectTab(tabIndex: Int) {&#10;        _uiState.update { it.copy(selectedTabIndex = tabIndex) }&#10;    }&#10;&#10;    fun updateTabIndex(tabIndex: Int) {&#10;        _uiState.update { it.copy(selectedTabIndex = tabIndex) }&#10;    }&#10;&#10;    fun loadAllUserEvaluations() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val evaluations = evaluationRepository.getAllUserEvaluations()&#10;                _uiState.update { it.copy(evaluations = evaluations) }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Failed to load evaluations: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getEvaluationDetail(evaluationId: Long) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val evaluationDetail = evaluationRepository.getEvaluationById(evaluationId)&#10;                _uiState.update { it.copy(selectedEvaluationDetail = evaluationDetail) }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Failed to load evaluation detail: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val profile = userRepository.getUserProfile()&#10;                _uiState.update {&#10;                    it.copy(&#10;                        email = profile.email,&#10;                        username = profile.username,&#10;                        profileImageUrl = profile.profileUrl&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateUsername(newUsername: String) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val updatedProfile = userRepository.setUsername(newUsername)&#10;                _uiState.update {&#10;                    it.copy(&#10;                        username = updatedProfile.username&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun uploadProfileImage(imageUrl: String) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val uploadedUrl = userRepository.uploadProfileImage(imageUrl)&#10;                _uiState.update { it.copy(profileImageUrl = uploadedUrl) }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteProfileImage() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val currentImageUrl = _uiState.value.profileImageUrl&#10;                if (currentImageUrl != null) {&#10;                    userRepository.deleteProfileImage(currentImageUrl)&#10;                }&#10;                _uiState.update { it.copy(profileImageUrl = null) }&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load user's stored LeetCode profile from database&#10;     * Called on init to check if user has already connected their LeetCode account&#10;     */&#10;    fun loadLeetCodeProfile() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.getLeetcodeProfile()&#10;                if (stats != null) {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                // Silently fail if no profile exists yet&#10;                _error.value = null&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set LeetCode username for the first time&#10;     * This will fetch fresh stats from LeetCode API and save to database&#10;     */&#10;    fun setLeetCodeUsername(username: String) {&#10;        if (username.isBlank()) {&#10;            _error.value = &quot;LeetCode username can't be empty&quot;&#10;            return&#10;        }&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.setLeetcodeUsername(username)&#10;                if (stats == null) {&#10;                    _error.value = &quot;Failed to fetch LeetCode stats. Please check the username.&quot;&#10;                } else {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Error: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update LeetCode username to a new one&#10;     * This will fetch fresh stats for the new username and save to database&#10;     */&#10;    fun updateLeetCodeUsername(username: String) {&#10;        if (username.isBlank()) {&#10;            _error.value = &quot;LeetCode username can't be empty&quot;&#10;            return&#10;        }&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.updateLeetcodeUsername(username)&#10;                if (stats == null) {&#10;                    _error.value = &quot;Failed to update LeetCode username. Please check the username.&quot;&#10;                } else {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Error: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh stats from LeetCode API for existing username&#10;     * Use this when user wants to manually update their stats&#10;     */&#10;    fun refreshLeetCodeStats() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;            try {&#10;                val stats = leetcodeRepository.refreshLeetcodeStats()&#10;                if (stats == null) {&#10;                    _error.value = &quot;Failed to refresh LeetCode stats&quot;&#10;                } else {&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            leetcodeUsername = stats.username,&#10;                            solvedCount = stats.totalSolved,&#10;                            solvedEasy = stats.easySolved,&#10;                            solvedMedium = stats.mediumSolved,&#10;                            solvedHard = stats.hardSolved,&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _error.value = &quot;Error: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/example/leetnote/ui/screens/solving/SolvingPageViewModelTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/example/leetnote/ui/screens/solving/SolvingPageViewModelTest.kt" />
              <option name="originalContent" value="package com.example.leetnote.ui.screens.solving&#10;&#10;import androidx.arch.core.executor.testing.InstantTaskExecutorRule&#10;import app.cash.turbine.test&#10;import com.example.leetnote.data.model.ProblemDetailDTO&#10;import com.example.leetnote.data.model.SolutionDTO&#10;import com.example.leetnote.data.model.SubmissionDTO&#10;import com.example.leetnote.data.model.EvaluationDetail&#10;import com.example.leetnote.data.model.EvaluationDTO&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;import com.example.leetnote.data.repository.EvaluationRepository&#10;import com.example.leetnote.data.repository.ProblemRepository&#10;import io.mockk.coEvery&#10;import io.mockk.coVerify&#10;import io.mockk.mockk&#10;import io.mockk.mockkStatic&#10;import io.mockk.unmockkStatic&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.test.StandardTestDispatcher&#10;import kotlinx.coroutines.test.resetMain&#10;import kotlinx.coroutines.test.runTest&#10;import kotlinx.coroutines.test.setMain&#10;import org.junit.After&#10;import org.junit.Assert.assertEquals&#10;import org.junit.Assert.assertFalse&#10;import org.junit.Assert.assertNull&#10;import org.junit.Assert.assertTrue&#10;import org.junit.Before&#10;import org.junit.Rule&#10;import org.junit.Test&#10;import java.io.IOException&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class SolvingPageViewModelTest {&#10;&#10;    @get:Rule&#10;    val instantTaskExecutorRule = InstantTaskExecutorRule()&#10;&#10;    private val testDispatcher = StandardTestDispatcher()&#10;    private lateinit var evaluationRepository: EvaluationRepository&#10;    private lateinit var problemRepository: ProblemRepository&#10;    private lateinit var viewModel: SolvingPageViewModel&#10;&#10;    // Test data&#10;    private val sampleSolution = SolutionDTO(&#10;        approach = &quot;Two Pointers&quot;,&#10;        code = &quot;class Solution {\n    public int[] twoSum(int[] nums, int target) {\n&quot; +&#10;            &quot;        // Implementation\n    }\n}&quot;,&#10;        timeComplexity = &quot;O(n)&quot;,&#10;        spaceComplexity = &quot;O(1)&quot;&#10;    )&#10;&#10;    private val sampleProblemDetail = ProblemDetailDTO(&#10;        id = 1L,&#10;        title = &quot;Two Sum&quot;,&#10;        description = &quot;Given an array of integers nums and an integer target, &quot; +&#10;            &quot;return indices of the two numbers such that they add up to target.&quot;,&#10;        difficulty = &quot;Easy&quot;,&#10;        isFavorite = false,&#10;        isSolved = false,&#10;        solution = sampleSolution&#10;    )&#10;&#10;    private val sampleSubmission = SubmissionDTO.Submission(&#10;        id = 1L,&#10;        problemId = 1L,&#10;        solutionText = &quot;def twoSum(nums, target):\n    # solution code\n    pass&quot;,&#10;        createdAt = &quot;2025-10-14T12:00:00Z&quot;&#10;    )&#10;&#10;    private val sampleEvaluationDTO = EvaluationDTO(&#10;        rating = 85,&#10;        issue = listOf(&quot;Missing edge case handling&quot;),&#10;        feedback = listOf(&quot;Good approach&quot;, &quot;Consider optimization&quot;)&#10;    )&#10;&#10;    private val sampleEvaluation = EvaluationDetail(&#10;        id = 1L,&#10;        version = 1,&#10;        evaluation = sampleEvaluationDTO,&#10;        createdAt = &quot;2025-10-14T12:05:00Z&quot;&#10;    )&#10;&#10;&#10;    @Before&#10;    fun setup() {&#10;        Dispatchers.setMain(testDispatcher)&#10;        evaluationRepository = mockk()&#10;        problemRepository = mockk()&#10;&#10;        // Mock Android Log to prevent &quot;Log not mocked&quot; errors&#10;        mockkStatic(android.util.Log::class)&#10;        coEvery { android.util.Log.e(any(), any(), any&lt;Throwable&gt;()) } returns 0&#10;        coEvery { android.util.Log.d(any(), any()) } returns 0&#10;&#10;        viewModel = SolvingPageViewModel(evaluationRepository, problemRepository)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        Dispatchers.resetMain()&#10;        unmockkStatic(android.util.Log::class)&#10;    }&#10;&#10;    @Test&#10;    fun `initial state should have empty and null values`() = runTest {&#10;        // Given - ViewModel is initialized&#10;&#10;        // When - Getting initial state&#10;        val problemDetail = viewModel.problemDetail.value&#10;        val solutionText = viewModel.solutionText.value&#10;        val isLoading = viewModel.isLoading.value&#10;        val lastSubmission = viewModel.lastSubmission.value&#10;        val lastEvaluation = viewModel.lastEvaluation.value&#10;        val allEvaluations = viewModel.allEvaluations.value&#10;        val evaluationResult = viewModel.evaluationResult.value&#10;        val error = viewModel.error.value&#10;&#10;        // Then - All values should be in initial state&#10;        assertNull(problemDetail)&#10;        assertEquals(&quot;&quot;, solutionText)&#10;        assertFalse(isLoading)&#10;        assertNull(lastSubmission)&#10;        assertNull(lastEvaluation)&#10;        assertEquals(emptyList&lt;EvaluationListItemDTO&gt;(), allEvaluations)&#10;        assertNull(evaluationResult)&#10;        assertNull(error)&#10;    }&#10;&#10;    @Test&#10;    fun `onSolutionTextChange should update solution text and clear error`() = runTest {&#10;        // Given&#10;        val newText = &quot;def solution():\n    return 42&quot;&#10;&#10;        // Set initial error&#10;        viewModel.clearError()&#10;        viewModel.onSolutionTextChange(&quot;test&quot;)&#10;&#10;        // When&#10;        viewModel.onSolutionTextChange(newText)&#10;&#10;        // Then&#10;        assertEquals(newText, viewModel.solutionText.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `clearError should reset error to null`() = runTest {&#10;        // Given - Simulate error state by loading invalid problem&#10;        coEvery { problemRepository.getProblemDetail(any()) } throws RuntimeException(&quot;Test error&quot;)&#10;&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Verify error is set&#10;        assertTrue(viewModel.error.value?.contains(&quot;Test error&quot;) == true)&#10;&#10;        // When&#10;        viewModel.clearError()&#10;&#10;        // Then&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loadProblemDetail should load problem successfully`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { problemRepository.getProblemDetail(problemId) } returns sampleProblemDetail&#10;&#10;        // When&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleProblemDetail, viewModel.problemDetail.value)&#10;        assertNull(viewModel.error.value)&#10;&#10;        coVerify { problemRepository.getProblemDetail(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `loadProblemDetail should handle exception and set error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val errorMsg = &quot;Network error&quot;&#10;        coEvery { problemRepository.getProblemDetail(problemId) } throws RuntimeException(errorMsg)&#10;&#10;        // When&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.problemDetail.value)&#10;        assertEquals(&quot;Failed to load problem detail: $errorMsg&quot;, viewModel.error.value)&#10;&#10;        coVerify { problemRepository.getProblemDetail(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should not submit if solution text is blank`() = runTest {&#10;        // Given - Empty solution text&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value)&#10;&#10;        // When&#10;        viewModel.submitSolution(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - No repository calls should be made&#10;        coVerify(exactly = 0) { evaluationRepository.createEvaluation(any()) }&#10;        // Loading should remain false since we return early&#10;        assertFalse(viewModel.isLoading.value)&#10;        // Evaluation result should remain null&#10;        assertNull(viewModel.evaluationResult.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should submit successfully and navigate to evaluation`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'answer'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When &amp; Then - Test navigation flow&#10;        viewModel.navigateToEvaluation.test {&#10;            viewModel.submitSolution(problemId)&#10;            testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;            // Then&#10;            assertFalse(viewModel.isLoading.value)&#10;            assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;            assertNull(viewModel.error.value)&#10;&#10;            // Should emit navigation event&#10;            assertEquals(sampleEvaluation, awaitItem())&#10;&#10;            coVerify {&#10;                evaluationRepository.createEvaluation(&#10;                    SubmissionDTO.SubmissionRequest(problemId, solutionText)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle timeout and set error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        // Simulate timeout by causing a delay longer than the timeout in ViewModel (10 seconds)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } coAnswers {&#10;            kotlinx.coroutines.delay(15000) // This will cause timeout in withTimeout(10000L)&#10;            sampleEvaluation&#10;        }&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - timeout should result in null evaluation and error message&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertEquals(&quot;Submission timed out. Please try again.&quot;, viewModel.error.value)&#10;&#10;        coVerify { evaluationRepository.createEvaluation(any()) }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle IOException and set network error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } throws IOException(&quot;Connection failed&quot;)&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertEquals(&quot;Cannot connect to server. Please check your network.&quot;, viewModel.error.value)&#10;&#10;        coVerify { evaluationRepository.createEvaluation(any()) }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle generic exception and set error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;        val errorMsg = &quot;Unexpected error occurred&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } throws RuntimeException(errorMsg)&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertEquals(&quot;Unexpected error: $errorMsg&quot;, viewModel.error.value)&#10;&#10;        coVerify { evaluationRepository.createEvaluation(any()) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should load submission successfully`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should update solution text if empty`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value) // Initially empty&#10;&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleSubmission.solutionText, viewModel.solutionText.value)&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should not update solution text if not empty`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val existingSolution = &quot;existing solution code&quot;&#10;&#10;        viewModel.onSolutionTextChange(existingSolution)&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(existingSolution, viewModel.solutionText.value) // Should remain unchanged&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should handle exception and set null`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } throws RuntimeException(&quot;API error&quot;)&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastEvaluation should load evaluation successfully`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleEvaluation, viewModel.lastEvaluation.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getNewEvaluation(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastEvaluation should handle exception and set null`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } throws RuntimeException(&quot;API error&quot;)&#10;&#10;        // When&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastEvaluation.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getNewEvaluation(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `loading state should be managed correctly during operations`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } coAnswers {&#10;            kotlinx.coroutines.delay(100) // Simulate network delay&#10;            sampleSubmission&#10;        }&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - After completion, loading should be false&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;    }&#10;&#10;    @Test&#10;    fun `multiple concurrent operations should handle loading state correctly`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns sampleEvaluation&#10;&#10;        // When - Start multiple operations&#10;        viewModel.fetchLastSubmission(problemId)&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Both operations should complete successfully&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;        assertEquals(sampleEvaluation, viewModel.lastEvaluation.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;        coVerify { evaluationRepository.getNewEvaluation(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `solution text changes should clear error messages`() = runTest {&#10;        // Given - Set initial error&#10;        coEvery { problemRepository.getProblemDetail(any()) } throws RuntimeException(&quot;Test error&quot;)&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Verify error is set&#10;        assertTrue(viewModel.error.value?.contains(&quot;Test error&quot;) == true)&#10;&#10;        // When - Change solution text&#10;        viewModel.onSolutionTextChange(&quot;new solution&quot;)&#10;&#10;        // Then - Error should be cleared&#10;        assertNull(viewModel.error.value)&#10;        assertEquals(&quot;new solution&quot;, viewModel.solutionText.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution with whitespace only solution should not submit`() = runTest {&#10;        // Given - Solution text with only whitespace&#10;        viewModel.onSolutionTextChange(&quot;   \n\t  &quot;)&#10;&#10;        // When&#10;        viewModel.submitSolution(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - No repository calls should be made&#10;        coVerify(exactly = 0) { evaluationRepository.createEvaluation(any()) }&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loadProblemDetail should clear previous error before loading`() = runTest {&#10;        // Given - Set initial error&#10;        coEvery { problemRepository.getProblemDetail(1L) } throws RuntimeException(&quot;First error&quot;)&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;        assertTrue(viewModel.error.value?.contains(&quot;First error&quot;) == true)&#10;&#10;        // When - Load another problem successfully&#10;        coEvery { problemRepository.getProblemDetail(2L) } returns sampleProblemDetail&#10;        viewModel.loadProblemDetail(2L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Error should be cleared&#10;        assertNull(viewModel.error.value)&#10;        assertEquals(sampleProblemDetail, viewModel.problemDetail.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should clear previous error before submitting`() = runTest {&#10;        // Given - Set initial error and valid solution&#10;        coEvery { problemRepository.getProblemDetail(any()) } throws RuntimeException(&quot;Test error&quot;)&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;        assertTrue(viewModel.error.value != null)&#10;&#10;        viewModel.onSolutionTextChange(&quot;valid solution code&quot;)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.submitSolution(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Error should be cleared and evaluation result should be set&#10;        assertNull(viewModel.error.value)&#10;        assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should return null when no previous submission exists`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns null&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value) // Should remain empty&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastEvaluation should return null when no previous evaluation exists`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns null&#10;&#10;        // When&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastEvaluation.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should preserve solution text on failure`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } throws IOException(&quot;Network error&quot;)&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Solution text should not be cleared&#10;        assertEquals(solutionText, viewModel.solutionText.value)&#10;        assertEquals(&quot;Cannot connect to server. Please check your network.&quot;, viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `multiple loadProblemDetail calls should handle race conditions correctly`() = runTest {&#10;        // Given&#10;        val problem1 = sampleProblemDetail.copy(id = 1L, title = &quot;Problem 1&quot;)&#10;        val problem2 = sampleProblemDetail.copy(id = 2L, title = &quot;Problem 2&quot;)&#10;&#10;        coEvery { problemRepository.getProblemDetail(1L) } coAnswers {&#10;            kotlinx.coroutines.delay(100)&#10;            problem1&#10;        }&#10;        coEvery { problemRepository.getProblemDetail(2L) } returns problem2&#10;&#10;        // When - Trigger two loads, second one should complete first&#10;        viewModel.loadProblemDetail(1L)&#10;        viewModel.loadProblemDetail(2L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Should have the result from the last completed call&#10;        val finalProblem = viewModel.problemDetail.value&#10;        assertTrue(finalProblem?.id == 1L || finalProblem?.id == 2L)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle successful submission with empty feedback`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;perfect solution&quot;&#10;        val evaluationWithEmptyFeedback = sampleEvaluation.copy(&#10;            evaluation = sampleEvaluationDTO.copy(&#10;                rating = 100,&#10;                issue = emptyList(),&#10;                feedback = emptyList()&#10;            )&#10;        )&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns evaluationWithEmptyFeedback&#10;&#10;        // When&#10;        viewModel.navigateToEvaluation.test {&#10;            viewModel.submitSolution(problemId)&#10;            testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;            // Then&#10;            assertEquals(evaluationWithEmptyFeedback, viewModel.evaluationResult.value)&#10;            assertEquals(evaluationWithEmptyFeedback, awaitItem())&#10;            assertNull(viewModel.error.value)&#10;        }&#10;    }&#10;&#10;    @Test&#10;    fun `onSolutionTextChange with empty string should clear previous text`() = runTest {&#10;        // Given - Set initial solution text&#10;        viewModel.onSolutionTextChange(&quot;initial solution&quot;)&#10;        assertEquals(&quot;initial solution&quot;, viewModel.solutionText.value)&#10;&#10;        // When - Change to empty string&#10;        viewModel.onSolutionTextChange(&quot;&quot;)&#10;&#10;        // Then&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value)&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission with null response should not throw exception`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns null&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Should complete without error&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertNull(viewModel.error.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loading state should be false after successful operations`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { problemRepository.getProblemDetail(problemId) } returns sampleProblemDetail&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns sampleEvaluation&#10;&#10;        // When - Execute multiple operations&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Loading should be false after all operations complete&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loading state should be false after failed operations`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { problemRepository.getProblemDetail(problemId) } throws RuntimeException(&quot;Error&quot;)&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } throws RuntimeException(&quot;Error&quot;)&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } throws RuntimeException(&quot;Error&quot;)&#10;&#10;        // When - Execute multiple operations that fail&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Loading should be false after all operations complete&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution with very long solution text should work`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val longSolution = &quot;a&quot;.repeat(10000) // Very long solution&#10;        viewModel.onSolutionTextChange(longSolution)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution with special characters should work`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val specialCharSolution = &quot;def solution():\n    return \&quot;!@#$%^&amp;*()_+-=[]{}|;':,.&lt;&gt;?/~`\&quot;&quot;&#10;        viewModel.onSolutionTextChange(specialCharSolution)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `clearError called multiple times should remain null`() = runTest {&#10;        // When - Clear error multiple times&#10;        viewModel.clearError()&#10;        viewModel.clearError()&#10;        viewModel.clearError()&#10;&#10;        // Then&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should not override manually entered solution text`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val manualSolution = &quot;manually typed solution&quot;&#10;        val fetchedSubmission = sampleSubmission.copy(solutionText = &quot;fetched solution&quot;)&#10;&#10;        // User types solution first&#10;        viewModel.onSolutionTextChange(manualSolution)&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns fetchedSubmission&#10;&#10;        // When - Fetch last submission after user has typed&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Manual solution should be preserved&#10;        assertEquals(manualSolution, viewModel.solutionText.value)&#10;        assertEquals(fetchedSubmission, viewModel.lastSubmission.value)&#10;    }&#10;&#10;    @Test&#10;    fun `evaluationResult should be updated after successful submission`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;test solution&quot;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;&#10;        val firstEvaluation = sampleEvaluation.copy(id = 1L)&#10;        val secondEvaluation = sampleEvaluation.copy(id = 2L)&#10;&#10;        // First submission&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns firstEvaluation&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;        assertEquals(firstEvaluation, viewModel.evaluationResult.value)&#10;&#10;        // Second submission with new solution&#10;        viewModel.onSolutionTextChange(&quot;improved solution&quot;)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns secondEvaluation&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Should have latest evaluation&#10;        assertEquals(secondEvaluation, viewModel.evaluationResult.value)&#10;    }&#10;&#10;    @Test&#10;    fun `problem detail should be null before loadProblemDetail is called`() = runTest {&#10;        // Then - Initial state&#10;        assertNull(viewModel.problemDetail.value)&#10;    }&#10;&#10;    @Test&#10;    fun `all state flows should be initialized correctly`() = runTest {&#10;        // Then - Verify all initial states&#10;        assertNull(viewModel.problemDetail.value)&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertNull(viewModel.lastEvaluation.value)&#10;        assertEquals(emptyList&lt;EvaluationListItemDTO&gt;(), viewModel.allEvaluations.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.leetnote.ui.screens.solving&#10;&#10;import androidx.arch.core.executor.testing.InstantTaskExecutorRule&#10;import app.cash.turbine.test&#10;import com.example.leetnote.data.model.ProblemDetailDTO&#10;import com.example.leetnote.data.model.SolutionDTO&#10;import com.example.leetnote.data.model.SubmissionDTO&#10;import com.example.leetnote.data.model.EvaluationDetail&#10;import com.example.leetnote.data.model.EvaluationDTO&#10;import com.example.leetnote.data.model.EvaluationListItemDTO&#10;import com.example.leetnote.data.repository.EvaluationRepository&#10;import com.example.leetnote.data.repository.ProblemRepository&#10;import io.mockk.coEvery&#10;import io.mockk.coVerify&#10;import io.mockk.mockk&#10;import io.mockk.mockkStatic&#10;import io.mockk.unmockkStatic&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.test.StandardTestDispatcher&#10;import kotlinx.coroutines.test.resetMain&#10;import kotlinx.coroutines.test.runTest&#10;import kotlinx.coroutines.test.setMain&#10;import org.junit.After&#10;import org.junit.Assert.assertEquals&#10;import org.junit.Assert.assertFalse&#10;import org.junit.Assert.assertNull&#10;import org.junit.Assert.assertTrue&#10;import org.junit.Before&#10;import org.junit.Rule&#10;import org.junit.Test&#10;import java.io.IOException&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class SolvingPageViewModelTest {&#10;&#10;    @get:Rule&#10;    val instantTaskExecutorRule = InstantTaskExecutorRule()&#10;&#10;    private val testDispatcher = StandardTestDispatcher()&#10;    private lateinit var evaluationRepository: EvaluationRepository&#10;    private lateinit var problemRepository: ProblemRepository&#10;    private lateinit var viewModel: SolvingPageViewModel&#10;&#10;    // Test data&#10;    private val sampleSolution = SolutionDTO(&#10;        approach = &quot;Two Pointers&quot;,&#10;        code = &quot;class Solution {\n    public int[] twoSum(int[] nums, int target) {\n&quot; +&#10;            &quot;        // Implementation\n    }\n}&quot;,&#10;        timeComplexity = &quot;O(n)&quot;,&#10;        spaceComplexity = &quot;O(1)&quot;&#10;    )&#10;&#10;    private val sampleProblemDetail = ProblemDetailDTO(&#10;        id = 1L,&#10;        title = &quot;Two Sum&quot;,&#10;        description = &quot;Given an array of integers nums and an integer target, &quot; +&#10;            &quot;return indices of the two numbers such that they add up to target.&quot;,&#10;        difficulty = &quot;Easy&quot;,&#10;        isFavorite = false,&#10;        isSolved = false,&#10;        solution = sampleSolution&#10;    )&#10;&#10;    private val sampleSubmission = SubmissionDTO.Submission(&#10;        id = 1L,&#10;        problemId = 1L,&#10;        solutionText = &quot;def twoSum(nums, target):\n    # solution code\n    pass&quot;,&#10;        createdAt = &quot;2025-10-14T12:00:00Z&quot;&#10;    )&#10;&#10;    private val sampleEvaluationDTO = EvaluationDTO(&#10;        rating = 85,&#10;        issue = listOf(&quot;Missing edge case handling&quot;),&#10;        feedback = listOf(&quot;Good approach&quot;, &quot;Consider optimization&quot;)&#10;    )&#10;&#10;    private val sampleEvaluation = EvaluationDetail(&#10;        id = 1L,&#10;        version = 1,&#10;        evaluation = sampleEvaluationDTO,&#10;        createdAt = &quot;2025-10-14T12:05:00Z&quot;&#10;    )&#10;&#10;&#10;    @Before&#10;    fun setup() {&#10;        Dispatchers.setMain(testDispatcher)&#10;        evaluationRepository = mockk()&#10;        problemRepository = mockk()&#10;&#10;        // Mock Android Log to prevent &quot;Log not mocked&quot; errors&#10;        mockkStatic(android.util.Log::class)&#10;        coEvery { android.util.Log.e(any(), any(), any&lt;Throwable&gt;()) } returns 0&#10;        coEvery { android.util.Log.d(any(), any()) } returns 0&#10;&#10;        viewModel = SolvingPageViewModel(evaluationRepository, problemRepository)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        Dispatchers.resetMain()&#10;        unmockkStatic(android.util.Log::class)&#10;    }&#10;&#10;    @Test&#10;    fun `initial state should have empty and null values`() = runTest {&#10;        // Given - ViewModel is initialized&#10;&#10;        // When - Getting initial state&#10;        val problemDetail = viewModel.problemDetail.value&#10;        val solutionText = viewModel.solutionText.value&#10;        val isLoading = viewModel.isLoading.value&#10;        val lastSubmission = viewModel.lastSubmission.value&#10;        val lastEvaluation = viewModel.lastEvaluation.value&#10;        val allEvaluations = viewModel.allEvaluations.value&#10;        val evaluationResult = viewModel.evaluationResult.value&#10;        val error = viewModel.error.value&#10;&#10;        // Then - All values should be in initial state&#10;        assertNull(problemDetail)&#10;        assertEquals(&quot;&quot;, solutionText)&#10;        assertFalse(isLoading)&#10;        assertNull(lastSubmission)&#10;        assertNull(lastEvaluation)&#10;        assertEquals(emptyList&lt;EvaluationListItemDTO&gt;(), allEvaluations)&#10;        assertNull(evaluationResult)&#10;        assertNull(error)&#10;    }&#10;&#10;    @Test&#10;    fun `onSolutionTextChange should update solution text and clear error`() = runTest {&#10;        // Given&#10;        val newText = &quot;def solution():\n    return 42&quot;&#10;&#10;        // Set initial error&#10;        viewModel.clearError()&#10;        viewModel.onSolutionTextChange(&quot;test&quot;)&#10;&#10;        // When&#10;        viewModel.onSolutionTextChange(newText)&#10;&#10;        // Then&#10;        assertEquals(newText, viewModel.solutionText.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `clearError should reset error to null`() = runTest {&#10;        // Given - Simulate error state by loading invalid problem&#10;        coEvery { problemRepository.getProblemDetail(any()) } throws RuntimeException(&quot;Test error&quot;)&#10;&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Verify error is set&#10;        assertTrue(viewModel.error.value?.contains(&quot;Test error&quot;) == true)&#10;&#10;        // When&#10;        viewModel.clearError()&#10;&#10;        // Then&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loadProblemDetail should load problem successfully`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { problemRepository.getProblemDetail(problemId) } returns sampleProblemDetail&#10;&#10;        // When&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleProblemDetail, viewModel.problemDetail.value)&#10;        assertNull(viewModel.error.value)&#10;&#10;        coVerify { problemRepository.getProblemDetail(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `loadProblemDetail should handle exception and set error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val errorMsg = &quot;Network error&quot;&#10;        coEvery { problemRepository.getProblemDetail(problemId) } throws RuntimeException(errorMsg)&#10;&#10;        // When&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.problemDetail.value)&#10;        assertEquals(&quot;Failed to load problem detail: $errorMsg&quot;, viewModel.error.value)&#10;&#10;        coVerify { problemRepository.getProblemDetail(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should not submit if solution text is blank`() = runTest {&#10;        // Given - Empty solution text&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value)&#10;&#10;        // When&#10;        viewModel.submitSolution(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - No repository calls should be made&#10;        coVerify(exactly = 0) { evaluationRepository.createEvaluation(any()) }&#10;        // Loading should remain false since we return early&#10;        assertFalse(viewModel.isLoading.value)&#10;        // Evaluation result should remain null&#10;        assertNull(viewModel.evaluationResult.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should submit successfully and navigate to evaluation`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'answer'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When &amp; Then - Test navigation flow&#10;        viewModel.navigateToEvaluation.test {&#10;            viewModel.submitSolution(problemId)&#10;            testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;            // Then&#10;            assertFalse(viewModel.isLoading.value)&#10;            assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;            assertNull(viewModel.error.value)&#10;&#10;            // Should emit navigation event&#10;            assertEquals(sampleEvaluation, awaitItem())&#10;&#10;            coVerify {&#10;                evaluationRepository.createEvaluation(&#10;                    SubmissionDTO.SubmissionRequest(problemId, solutionText)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle timeout and set error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        // Simulate timeout by causing a delay longer than the timeout in ViewModel (10 seconds)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } coAnswers {&#10;            kotlinx.coroutines.delay(15000) // This will cause timeout in withTimeout(10000L)&#10;            sampleEvaluation&#10;        }&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - timeout should result in null evaluation and error message&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertEquals(&quot;Submission timed out. Please try again.&quot;, viewModel.error.value)&#10;&#10;        coVerify { evaluationRepository.createEvaluation(any()) }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle IOException and set network error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } throws IOException(&quot;Connection failed&quot;)&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertEquals(&quot;Cannot connect to server. Please check your network.&quot;, viewModel.error.value)&#10;&#10;        coVerify { evaluationRepository.createEvaluation(any()) }&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle generic exception and set error message`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;        val errorMsg = &quot;Unexpected error occurred&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } throws RuntimeException(errorMsg)&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertEquals(&quot;Unexpected error: $errorMsg&quot;, viewModel.error.value)&#10;&#10;        coVerify { evaluationRepository.createEvaluation(any()) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should load submission successfully`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should update solution text if empty`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value) // Initially empty&#10;&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleSubmission.solutionText, viewModel.solutionText.value)&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should not update solution text if not empty`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val existingSolution = &quot;existing solution code&quot;&#10;&#10;        viewModel.onSolutionTextChange(existingSolution)&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(existingSolution, viewModel.solutionText.value) // Should remain unchanged&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should handle exception and set null`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } throws RuntimeException(&quot;API error&quot;)&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastEvaluation should load evaluation successfully`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleEvaluation, viewModel.lastEvaluation.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getNewEvaluation(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastEvaluation should handle exception and set null`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } throws RuntimeException(&quot;API error&quot;)&#10;&#10;        // When&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastEvaluation.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getNewEvaluation(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `loading state should be managed correctly during operations`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } coAnswers {&#10;            kotlinx.coroutines.delay(100) // Simulate network delay&#10;            sampleSubmission&#10;        }&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - After completion, loading should be false&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;    }&#10;&#10;    @Test&#10;    fun `multiple concurrent operations should handle loading state correctly`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns sampleEvaluation&#10;&#10;        // When - Start multiple operations&#10;        viewModel.fetchLastSubmission(problemId)&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Both operations should complete successfully&#10;        assertEquals(sampleSubmission, viewModel.lastSubmission.value)&#10;        assertEquals(sampleEvaluation, viewModel.lastEvaluation.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;&#10;        coVerify { evaluationRepository.getLastSubmission(problemId) }&#10;        coVerify { evaluationRepository.getNewEvaluation(problemId) }&#10;    }&#10;&#10;    @Test&#10;    fun `solution text changes should clear error messages`() = runTest {&#10;        // Given - Set initial error&#10;        coEvery { problemRepository.getProblemDetail(any()) } throws RuntimeException(&quot;Test error&quot;)&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Verify error is set&#10;        assertTrue(viewModel.error.value?.contains(&quot;Test error&quot;) == true)&#10;&#10;        // When - Change solution text&#10;        viewModel.onSolutionTextChange(&quot;new solution&quot;)&#10;&#10;        // Then - Error should be cleared&#10;        assertNull(viewModel.error.value)&#10;        assertEquals(&quot;new solution&quot;, viewModel.solutionText.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution with whitespace only solution should not submit`() = runTest {&#10;        // Given - Solution text with only whitespace&#10;        viewModel.onSolutionTextChange(&quot;   \n\t  &quot;)&#10;&#10;        // When&#10;        viewModel.submitSolution(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - No repository calls should be made&#10;        coVerify(exactly = 0) { evaluationRepository.createEvaluation(any()) }&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loadProblemDetail should clear previous error before loading`() = runTest {&#10;        // Given - Set initial error&#10;        coEvery { problemRepository.getProblemDetail(1L) } throws RuntimeException(&quot;First error&quot;)&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;        assertTrue(viewModel.error.value?.contains(&quot;First error&quot;) == true)&#10;&#10;        // When - Load another problem successfully&#10;        coEvery { problemRepository.getProblemDetail(2L) } returns sampleProblemDetail&#10;        viewModel.loadProblemDetail(2L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Error should be cleared&#10;        assertNull(viewModel.error.value)&#10;        assertEquals(sampleProblemDetail, viewModel.problemDetail.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should clear previous error before submitting`() = runTest {&#10;        // Given - Set initial error and valid solution&#10;        coEvery { problemRepository.getProblemDetail(any()) } throws RuntimeException(&quot;Test error&quot;)&#10;        viewModel.loadProblemDetail(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;        assertTrue(viewModel.error.value != null)&#10;&#10;        viewModel.onSolutionTextChange(&quot;valid solution code&quot;)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.submitSolution(1L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Error should be cleared and evaluation result should be set&#10;        assertNull(viewModel.error.value)&#10;        assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should return null when no previous submission exists`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns null&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value) // Should remain empty&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastEvaluation should return null when no previous evaluation exists`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns null&#10;&#10;        // When&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertNull(viewModel.lastEvaluation.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should preserve solution text on failure`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;def solution():\n    return 'test'&quot;&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } throws IOException(&quot;Network error&quot;)&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Solution text should not be cleared&#10;        assertEquals(solutionText, viewModel.solutionText.value)&#10;        assertEquals(&quot;Cannot connect to server. Please check your network.&quot;, viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `multiple loadProblemDetail calls should handle race conditions correctly`() = runTest {&#10;        // Given&#10;        val problem1 = sampleProblemDetail.copy(id = 1L, title = &quot;Problem 1&quot;)&#10;        val problem2 = sampleProblemDetail.copy(id = 2L, title = &quot;Problem 2&quot;)&#10;&#10;        coEvery { problemRepository.getProblemDetail(1L) } coAnswers {&#10;            kotlinx.coroutines.delay(100)&#10;            problem1&#10;        }&#10;        coEvery { problemRepository.getProblemDetail(2L) } returns problem2&#10;&#10;        // When - Trigger two loads, second one should complete first&#10;        viewModel.loadProblemDetail(1L)&#10;        viewModel.loadProblemDetail(2L)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Should have the result from the last completed call&#10;        val finalProblem = viewModel.problemDetail.value&#10;        assertTrue(finalProblem?.id == 1L || finalProblem?.id == 2L)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution should handle successful submission with empty feedback`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;perfect solution&quot;&#10;        val evaluationWithEmptyFeedback = sampleEvaluation.copy(&#10;            evaluation = sampleEvaluationDTO.copy(&#10;                rating = 100,&#10;                issue = emptyList(),&#10;                feedback = emptyList()&#10;            )&#10;        )&#10;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns evaluationWithEmptyFeedback&#10;&#10;        // When&#10;        viewModel.navigateToEvaluation.test {&#10;            viewModel.submitSolution(problemId)&#10;            testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;            // Then&#10;            assertEquals(evaluationWithEmptyFeedback, viewModel.evaluationResult.value)&#10;            assertEquals(evaluationWithEmptyFeedback, awaitItem())&#10;            assertNull(viewModel.error.value)&#10;        }&#10;    }&#10;&#10;    @Test&#10;    fun `onSolutionTextChange with empty string should clear previous text`() = runTest {&#10;        // Given - Set initial solution text&#10;        viewModel.onSolutionTextChange(&quot;initial solution&quot;)&#10;        assertEquals(&quot;initial solution&quot;, viewModel.solutionText.value)&#10;&#10;        // When - Change to empty string&#10;        viewModel.onSolutionTextChange(&quot;&quot;)&#10;&#10;        // Then&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value)&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission with null response should not throw exception`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns null&#10;&#10;        // When&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Should complete without error&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertNull(viewModel.error.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loading state should be false after successful operations`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { problemRepository.getProblemDetail(problemId) } returns sampleProblemDetail&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns sampleSubmission&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } returns sampleEvaluation&#10;&#10;        // When - Execute multiple operations&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Loading should be false after all operations complete&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `loading state should be false after failed operations`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        coEvery { problemRepository.getProblemDetail(problemId) } throws RuntimeException(&quot;Error&quot;)&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } throws RuntimeException(&quot;Error&quot;)&#10;        coEvery { evaluationRepository.getNewEvaluation(problemId) } throws RuntimeException(&quot;Error&quot;)&#10;&#10;        // When - Execute multiple operations that fail&#10;        viewModel.loadProblemDetail(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        viewModel.fetchLastEvaluation(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Loading should be false after all operations complete&#10;        assertFalse(viewModel.isLoading.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution with very long solution text should work`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val longSolution = &quot;a&quot;.repeat(10000) // Very long solution&#10;        viewModel.onSolutionTextChange(longSolution)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `submitSolution with special characters should work`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val specialCharSolution = &quot;def solution():\n    return \&quot;!@#$%^&amp;*()_+-=[]{}|;':,.&lt;&gt;?/~`\&quot;&quot;&#10;        viewModel.onSolutionTextChange(specialCharSolution)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns sampleEvaluation&#10;&#10;        // When&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then&#10;        assertEquals(sampleEvaluation, viewModel.evaluationResult.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `clearError called multiple times should remain null`() = runTest {&#10;        // When - Clear error multiple times&#10;        viewModel.clearError()&#10;        viewModel.clearError()&#10;        viewModel.clearError()&#10;&#10;        // Then&#10;        assertNull(viewModel.error.value)&#10;    }&#10;&#10;    @Test&#10;    fun `fetchLastSubmission should not override manually entered solution text`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val manualSolution = &quot;manually typed solution&quot;&#10;        val fetchedSubmission = sampleSubmission.copy(solutionText = &quot;fetched solution&quot;)&#10;&#10;        // User types solution first&#10;        viewModel.onSolutionTextChange(manualSolution)&#10;        coEvery { evaluationRepository.getLastSubmission(problemId) } returns fetchedSubmission&#10;&#10;        // When - Fetch last submission after user has typed&#10;        viewModel.fetchLastSubmission(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Manual solution should be preserved&#10;        assertEquals(manualSolution, viewModel.solutionText.value)&#10;        assertEquals(fetchedSubmission, viewModel.lastSubmission.value)&#10;    }&#10;&#10;    @Test&#10;    fun `evaluationResult should be updated after successful submission`() = runTest {&#10;        // Given&#10;        val problemId = 1L&#10;        val solutionText = &quot;test solution&quot;&#10;        viewModel.onSolutionTextChange(solutionText)&#10;&#10;        val firstEvaluation = sampleEvaluation.copy(id = 1L)&#10;        val secondEvaluation = sampleEvaluation.copy(id = 2L)&#10;&#10;        // First submission&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns firstEvaluation&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;        assertEquals(firstEvaluation, viewModel.evaluationResult.value)&#10;&#10;        // Second submission with new solution&#10;        viewModel.onSolutionTextChange(&quot;improved solution&quot;)&#10;        coEvery { evaluationRepository.createEvaluation(any()) } returns secondEvaluation&#10;        viewModel.submitSolution(problemId)&#10;        testDispatcher.scheduler.advanceUntilIdle()&#10;&#10;        // Then - Should have latest evaluation&#10;        assertEquals(secondEvaluation, viewModel.evaluationResult.value)&#10;    }&#10;&#10;    @Test&#10;    fun `problem detail should be null before loadProblemDetail is called`() = runTest {&#10;        // Then - Initial state&#10;        assertNull(viewModel.problemDetail.value)&#10;    }&#10;&#10;    @Test&#10;    fun `all state flows should be initialized correctly`() = runTest {&#10;        // Then - Verify all initial states&#10;        assertNull(viewModel.problemDetail.value)&#10;        assertEquals(&quot;&quot;, viewModel.solutionText.value)&#10;        assertFalse(viewModel.isLoading.value)&#10;        assertNull(viewModel.lastSubmission.value)&#10;        assertNull(viewModel.lastEvaluation.value)&#10;        assertEquals(emptyList&lt;EvaluationListItemDTO&gt;(), viewModel.allEvaluations.value)&#10;        assertNull(viewModel.evaluationResult.value)&#10;        assertNull(viewModel.error.value)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>